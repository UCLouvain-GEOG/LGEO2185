[
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Create an R script, where you plot the mean, drawn from a normal distribution as function of the sample size. You should use the following elements: * rnorm() * matrix() * plot() * for {}\nMake a function where the user can change the sample size considered, and the variables of the normal distribution.\nBonus: do not use any for loops :-)\n\n\n\n\n\n\n\nImportantAnswer\n\n\n\n\n\n\n\n\n\nHard-coding of some parameters\nuse ... in function definition but not used within\nscript within for loop is not indented (not needed but lacks clarity)\nThe argument mean shadows the built-in mean() function (same for c). While this doesn’t immediately cause an error, it is bad practice because it can lead to confusion and bugs in more complex code where mean() might be expected.\nThe function doesn’t return any value. While it produces a plot, the underlying data (e.g., the matrix mat) isn’t accessible for further analysis. A good practice is to return the data structure used for plotting.\nInside the loop, the line c &lt;- c(2:1500) unnecessarily creates the same vector on every iteration.\n\n\nmyfun &lt;- function(mean, std, ...) {\n    # Generate 1500 random numbers from a normal distribution\n    random &lt;- rnorm(1500, mean = mean, sd = std)\n\n    # Create a matrix to store the sample size and sample means\n    mat &lt;- matrix(0, nrow = 1499, ncol = 2)\n\n    # Loop to calculate running means as sample size increases\n    for (i in 2:1500) {\n        moy &lt;- mean(random[1:i]) # Calculate the mean of the first 'i' samples\n        mat[i - 1, 2] &lt;- moy # Store the mean in the second column\n        c &lt;- c(2:1500) # Vector of sample sizes from 2 to 1500\n        mat[i - 1, 1] &lt;- c[i - 1] # Store the sample size in the first column\n    }\n\n    # Name the columns of the matrix\n    colnames(mat) &lt;- c(\"Size\", \"Mean\")\n\n    # Plot the sample size vs running mean\n    plot(mat, type = \"l\") # Line graph of sample size vs running mean\n    abline(mean, 0, col = \"red\") # Add a red horizontal line at the population mean\n}\n\n# Test the function\nmyfun(3, 4)\n\n\n\n\n\n\n\n\n\n\n\n\nWell documented\nUsing a relevant function name\n\n\n# Function to create mean vs. samplesize drawn from a normal distribution\nLawOfLargeNumbers &lt;- function(samplesize, mean, stdev) {\n    # samplesize: integer, number of samples\n    # mean: real, population mean\n    # stdev: real, population standard deviation\n    # Return: vector (size = samplesize) with running means\n\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mean, sd = stdev)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(0, samplesize),\n        ylim = c(-stdev, stdev),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(0, 0, col = \"red\") # Add a horizontal red line at y = 0\n\n    # Return the vector of running means\n    return(data_result)\n}\n\n# Generate running means for 100 samples, mean = 0, stdev = 1\nmeanvsss &lt;- LawOfLargeNumbers(100, 0, 1)\n\n\n\n\n\n\n\nhead(meanvsss)\n\n[1] -0.5325809 -0.3306114 -0.3289002 -0.2172562 -0.1157797 -0.2324585\n\n\n\n\n\n\nPro tip: Use CTRL+SHIFT+R to your function, a way to organize documentation of function parameters and that can be used to create R documentation files (Rd)\n\n\n#' The Law of Large Numbers\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return A numeric vector of size \\code{samplesize}, containing the running means.\n#' @details The function generates a population distribution with the specified mean and\n#' standard deviation, calculates the running means for increasing sample sizes,\n#' and plots the running means against the sample size. A red horizontal line is drawn\n#' for the given \\code{mean}.\n#'\n#' @examples\n#' # Example usage:\n#' LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n\n    # Return the vector of running means\n    return(data_result)\n}\n\n\n\n\n\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nhead(LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1))\n\n[1]  1.1289588 -0.1682474 -0.5175569 -0.6561757 -0.5586824 -0.6814961\n\n\n\n\n\nThis OOP approach organizes the functionality into reusable methods and encapsulates the data and operations, making it easier to extend and maintain.\n\n#' The Law of Large Numbers (OOP with S3 Plot)\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return An object of class \\code{LawOfLargeNumbers}, containing the running means\n#' and the parameters used.\n#' @details The object has a custom \\code{plot()} method to visualize the running means against the sample size.\n#'\n#' @examples\n#' # Example usage:\n#' lln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#' plot(lln)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate population distribution and calculate running means\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n    running_sums &lt;- cumsum(pop_dist)\n    running_means &lt;- running_sums / seq_len(samplesize)\n\n    # Return the object with its associated class\n    structure(\n        list(\n            samplesize = samplesize,\n            mu = mu,\n            sigma = sigma,\n            running_means = running_means\n        ),\n        class = \"LawOfLargeNumbers\"\n    )\n}\n\n# Define a plot method for the LawOfLargeNumbers class\nplot.LawOfLargeNumbers &lt;- function(x, ...) {\n    # Extract information from the object\n    samplesize &lt;- x$samplesize\n    mu &lt;- x$mu\n    sigma &lt;- x$sigma\n    running_means &lt;- x$running_means\n\n    # Create the plot\n    plot(running_means,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(running_means) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n}\n\n# Create an object of class LawOfLargeNumbers\nlln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n\n# Plot the running means\nplot(lln)\n\n\n\n\n\n\n\n\n\n\n\n\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in rnorm(samplesize, mean = mu, sd = sigma): invalid arguments\n\n# Do some sanity checks\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Input validation\n    if (!is.numeric(samplesize) || samplesize &lt;= 0 || samplesize != as.integer(samplesize)) {\n        stop(\"samplesize must be a positive integer.\")\n    }\n    if (!is.numeric(mu)) stop(\"mu must be numeric.\")\n    if (!is.numeric(sigma) || sigma &lt;= 0) stop(\"sigma must be a positive numeric value.\")\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in LawOfLargeNumbers(-100, 0, 1): samplesize must be a positive integer."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#hard-coding",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#hard-coding",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Hard-coding of some parameters\nuse ... in function definition but not used within\nscript within for loop is not indented (not needed but lacks clarity)\nThe argument mean shadows the built-in mean() function (same for c). While this doesn’t immediately cause an error, it is bad practice because it can lead to confusion and bugs in more complex code where mean() might be expected.\nThe function doesn’t return any value. While it produces a plot, the underlying data (e.g., the matrix mat) isn’t accessible for further analysis. A good practice is to return the data structure used for plotting.\nInside the loop, the line c &lt;- c(2:1500) unnecessarily creates the same vector on every iteration.\n\n\nmyfun &lt;- function(mean, std, ...) {\n    # Generate 1500 random numbers from a normal distribution\n    random &lt;- rnorm(1500, mean = mean, sd = std)\n\n    # Create a matrix to store the sample size and sample means\n    mat &lt;- matrix(0, nrow = 1499, ncol = 2)\n\n    # Loop to calculate running means as sample size increases\n    for (i in 2:1500) {\n        moy &lt;- mean(random[1:i]) # Calculate the mean of the first 'i' samples\n        mat[i - 1, 2] &lt;- moy # Store the mean in the second column\n        c &lt;- c(2:1500) # Vector of sample sizes from 2 to 1500\n        mat[i - 1, 1] &lt;- c[i - 1] # Store the sample size in the first column\n    }\n\n    # Name the columns of the matrix\n    colnames(mat) &lt;- c(\"Size\", \"Mean\")\n\n    # Plot the sample size vs running mean\n    plot(mat, type = \"l\") # Line graph of sample size vs running mean\n    abline(mean, 0, col = \"red\") # Add a red horizontal line at the population mean\n}\n\n# Test the function\nmyfun(3, 4)"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#solutions",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#solutions",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Well documented\nUsing a relevant function name\n\n\n# Function to create mean vs. samplesize drawn from a normal distribution\nLawOfLargeNumbers &lt;- function(samplesize, mean, stdev) {\n    # samplesize: integer, number of samples\n    # mean: real, population mean\n    # stdev: real, population standard deviation\n    # Return: vector (size = samplesize) with running means\n\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mean, sd = stdev)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(0, samplesize),\n        ylim = c(-stdev, stdev),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(0, 0, col = \"red\") # Add a horizontal red line at y = 0\n\n    # Return the vector of running means\n    return(data_result)\n}\n\n# Generate running means for 100 samples, mean = 0, stdev = 1\nmeanvsss &lt;- LawOfLargeNumbers(100, 0, 1)\n\n\n\n\n\n\n\nhead(meanvsss)\n\n[1] -0.5325809 -0.3306114 -0.3289002 -0.2172562 -0.1157797 -0.2324585"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#improved-documentation",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#improved-documentation",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Pro tip: Use CTRL+SHIFT+R to your function, a way to organize documentation of function parameters and that can be used to create R documentation files (Rd)\n\n\n#' The Law of Large Numbers\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return A numeric vector of size \\code{samplesize}, containing the running means.\n#' @details The function generates a population distribution with the specified mean and\n#' standard deviation, calculates the running means for increasing sample sizes,\n#' and plots the running means against the sample size. A red horizontal line is drawn\n#' for the given \\code{mean}.\n#'\n#' @examples\n#' # Example usage:\n#' LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n\n    # Return the vector of running means\n    return(data_result)\n}"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#instead-of-loops-use-vectorization",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#instead-of-loops-use-vectorization",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "LawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nhead(LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1))\n\n[1]  1.1289588 -0.1682474 -0.5175569 -0.6561757 -0.5586824 -0.6814961"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#pro-use-object-oriented-design",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#pro-use-object-oriented-design",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "This OOP approach organizes the functionality into reusable methods and encapsulates the data and operations, making it easier to extend and maintain.\n\n#' The Law of Large Numbers (OOP with S3 Plot)\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return An object of class \\code{LawOfLargeNumbers}, containing the running means\n#' and the parameters used.\n#' @details The object has a custom \\code{plot()} method to visualize the running means against the sample size.\n#'\n#' @examples\n#' # Example usage:\n#' lln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#' plot(lln)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate population distribution and calculate running means\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n    running_sums &lt;- cumsum(pop_dist)\n    running_means &lt;- running_sums / seq_len(samplesize)\n\n    # Return the object with its associated class\n    structure(\n        list(\n            samplesize = samplesize,\n            mu = mu,\n            sigma = sigma,\n            running_means = running_means\n        ),\n        class = \"LawOfLargeNumbers\"\n    )\n}\n\n# Define a plot method for the LawOfLargeNumbers class\nplot.LawOfLargeNumbers &lt;- function(x, ...) {\n    # Extract information from the object\n    samplesize &lt;- x$samplesize\n    mu &lt;- x$mu\n    sigma &lt;- x$sigma\n    running_means &lt;- x$running_means\n\n    # Create the plot\n    plot(running_means,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(running_means) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n}\n\n# Create an object of class LawOfLargeNumbers\nlln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n\n# Plot the running means\nplot(lln)"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#dont-forget-input-validation",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#dont-forget-input-validation",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "LawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in rnorm(samplesize, mean = mu, sd = sigma): invalid arguments\n\n# Do some sanity checks\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Input validation\n    if (!is.numeric(samplesize) || samplesize &lt;= 0 || samplesize != as.integer(samplesize)) {\n        stop(\"samplesize must be a positive integer.\")\n    }\n    if (!is.numeric(mu)) stop(\"mu must be numeric.\")\n    if (!is.numeric(sigma) || sigma &lt;= 0) stop(\"sigma must be a positive numeric value.\")\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in LawOfLargeNumbers(-100, 0, 1): samplesize must be a positive integer."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html",
    "href": "R Basics/LGEO2185_IntroductionR.html",
    "title": "LGEO2185: Introduction To R",
    "section": "",
    "text": "R syntax (self-study)\nBasic R controls\nFun with R functions\nAssignment"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#todays-program",
    "href": "R Basics/LGEO2185_IntroductionR.html#todays-program",
    "title": "LGEO2185: Introduction To R",
    "section": "",
    "text": "R syntax (self-study)\nBasic R controls\nFun with R functions\nAssignment"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#todays-learning-objectives",
    "href": "R Basics/LGEO2185_IntroductionR.html#todays-learning-objectives",
    "title": "LGEO2185: Introduction To R",
    "section": "Today’s Learning Objectives",
    "text": "Today’s Learning Objectives\n\nKnowing what R is & what you can do with it\n\nGetting comfortable with functions\n\nLearn the basics of working with R\n\nThis first session is giving you basics of R, if you’re comfortable with the software, you can go directly to the assignments.\nWe will be using RStudio (IDE) or Positron as interface to R and geospatial libraries, since with R we can easily visualize and analyse data and maps!\n\n\n\n\n\n\nNote\n\n\n\nAnother option would it be Python, but here we use R here as it is easy to use across different platforms and there is a very active communities developing spatial libraries. However, all the skills from R are transferable to Python, the main difference is the syntax and available libraries. Note that libraries are called ‘Packages’ in R.\n\n\nThe first step is to explore the Rstudio environment - Source window - Console window - Environment window (including history) - Files, Plots, Packages, Viewer etc…\n\n\n\nSource: https://rstudio.github.io/cheatsheets/html/rstudio-ide.html\n\n\nPositron looks very similar but is based on a fork of Visual Studio Code, and adds support to Python as well. It features an integrated Console, Environment/Variables, Plots, Files, and Git tools familiar to RStudio users"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#self-study",
    "href": "R Basics/LGEO2185_IntroductionR.html#self-study",
    "title": "LGEO2185: Introduction To R",
    "section": "1.1 Self-Study",
    "text": "1.1 Self-Study\nSelf-study: follow the online course: Try R codeschool. This should allow you to understand the syntax used in R-scripts and how to manipulate different types of variables. There are a lot of references about computing with R !\n\n\n\n\n\n\nNote\n\n\n\nYou should develop a self-proficiency of R by yourself. We will look into using GenAI tools to augment your abilities later in the course, but a solid baseline is a pre-requisite: focus first on core syntax, data structures (vectors, matrices, data frames), and functions, practicing with small scripts and the provided references; once comfortable, we will introduce GenAI to responsibly accelerate your workflow."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#setting-your-working-environment",
    "href": "R Basics/LGEO2185_IntroductionR.html#setting-your-working-environment",
    "title": "LGEO2185: Introduction To R",
    "section": "1.2 Setting your working environment",
    "text": "1.2 Setting your working environment\nLet’s first do some basic setup:\n- Create a folder which will be your working directory e.g. C:/Users/YourName/YourFolder\n- Create an R script within that folder\n- Create a data folder within your working directory\n\ngetwd() \nsetwd(\"C:/Users/YourName/YourFolder\") # This sets the working directory (where R looks for files)\ngetwd() # Double check your working directory \n\n\nwd=getwd()\ndatadir &lt;- paste0(wd,\"/data\")  # here we create a name for a subfolder called 'data'\ndir.create(datadir) # this creates the subdirectory\n\nYou will see that the variable datadir, i.e. the variable that you created above, is now visible in your workspace (Environment) and you can evaluate its value by clicking on it. Check out what Type the variables are. Create a vector and check again (you can see the type in the Environment, but also by calling the class() function)\nIf you are trying out code, it can be useful to clear all the variables that are stored in the workspace; this can be done by using:\nrm(list=ls()) # this removes all variables in the current workspace\nAlternatively, you can click Clear Workspace in the Session menu of the RStudio interface."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#function-basics",
    "href": "R Basics/LGEO2185_IntroductionR.html#function-basics",
    "title": "LGEO2185: Introduction To R",
    "section": "1.3 Function basics",
    "text": "1.3 Function basics\nR functions take the form: functionName(arguments)\n\narguments are often optional (functions use default values)\nif arguments are not named, their position is used to assign values to arguments\nlaziness in argument naming is allowed, but dangerous\n\n\n# the following commands are equivalent\nrnorm(n=10)\n\n [1]  1.58560372 -0.47864440  1.74647018  1.89092552  0.08291893 -0.06892676\n [7]  0.71800581 -0.21677652 -0.68091761  0.86379995\n\nrnorm(n=10,mean=0,sd=1)\n\n [1]  1.3790711  0.1035343  1.5884846 -1.3275688  1.3242383  0.2457179\n [7]  0.9207915  1.2387290  0.7373910  1.2183449\n\nrnorm(10,0,1)\n\n [1]  0.6895248  0.5929848 -0.2701429  0.8745817 -1.3544977 -0.5625965\n [7] -2.9177592  3.5343949 -0.8135975  0.2288322\n\nrnorm(10,s=1,m=0)\n\n [1] -1.5840742 -2.3300414 -0.7542426 -0.1652430  1.5718015  0.4158793\n [7]  0.6335208 -0.7268635  0.4980886  0.2473838\n\n\nAccessing the help files can be done like this for a particular function;\n\n?mean\n\nIf you are looking for help files for a word or a phrase, use:\n\nhelp.search('weighted mean')"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#math",
    "href": "R Basics/LGEO2185_IntroductionR.html#math",
    "title": "LGEO2185: Introduction To R",
    "section": "1.4 Math",
    "text": "1.4 Math\nR could be used as a simple calculator, so you can easily find basics mathematics’s function that could be useful to integrate. Moreover, don’t forget your statistics knowledge that you have learned with your wonderful assistant with your best friend summary()."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#r-objects",
    "href": "R Basics/LGEO2185_IntroductionR.html#r-objects",
    "title": "LGEO2185: Introduction To R",
    "section": "1.5 R objects",
    "text": "1.5 R objects\nNew objects are created via the assignment operator : -&gt;\n\nx &lt;- 1\n# or 1 -&gt; x  : this can go one way or another\nx = 1 # This is an alternative, but not recommended\n\nAll R objects have two intrinsic attributes: mode (numeric, character, complex, logical) and length\n\ny &lt;- \"This is a character string\"\nz &lt;- TRUE # or alternatively: z &lt;- T\n!z\nmode(x);mode(y);mode(z) # the symbol ; can be used to put \n                         #several command in the same line\nlength(x)\n\n\nNon _intrinsic attributes of objects (eg row names, dimension, etc) can be accessed via the attributes function\nTesting the type of the object: is.numeric, is.character, etc…\nCoerce from one type to another: as.numeric, as.character, etc…\nMissing values and NULL object\n\n\nx &lt;- NA # NA means 'Not Available'\nx + 1 # Any operation on a NA gives a NA\n\n[1] NA\n\nx &lt;- NULL\nx + 1 # it returns a numeric object of length == 0\n\nnumeric(0)\n\n0/0 # NaN means 'Not a Number'\n\n[1] NaN\n\n1/0 # Infinity\n\n[1] Inf\n\n\nThere are several types of objects in R:\n\nsource: http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf\n\n1.5.1 Vectors\n\nCreating vectors\nThe easiest way to create a vector is to use the c (combine) function\n\nmy_vector &lt;- c(2, 4, 6)\nprint(my_vector)\n\n[1] 2 4 6\n\n\nThese are different ways to create vectors using a sequence:\n\n# an integer sequence\nv &lt;- 2:6\nv\n\n[1] 2 3 4 5 6\n\n# a complex sequence\nv &lt;- seq(2, 3, by=0.5)\nv\n\n[1] 2.0 2.5 3.0\n\n# a repeat vector\nv &lt;- rep(1:2, times = 3)\nv\n\n[1] 1 2 1 2 1 2\n\n# repeat elements of a vector\nv &lt;- rep(1:2, each=3)\nv\n\n[1] 1 1 1 2 2 2\n\n\n\narithmetic operators on numeric vectors are: +, -, *, /, ^, %% (modulus), %/% (integer division)\n\nlogical operators are: &lt;, &gt;, !=, ==, &lt;=, &gt;=, & (AND), | (OR), ! (negation)\nUsual functions applied to numeric vectors are: sqrt, sin, cos, tan, log, log10, exp, round, floor, ceiling, abs\n\nUsual summary functions are: min, max, sum, mean, median, sd, var, cumsum\n\nUsual functions to handle character strings are: paste, substr and grep, sub\n\n\nx &lt;- paste(\"var\",1:10,sep=\"_\");x # concatenate strings\n\n [1] \"var_1\"  \"var_2\"  \"var_3\"  \"var_4\"  \"var_5\"  \"var_6\"  \"var_7\"  \"var_8\" \n [9] \"var_9\"  \"var_10\"\n\nsubstr(x,start=1,stop=3) # extract and replace substrings in a character vector \n\n [1] \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\"\n\nsub(pattern=\"[^1-9]+\",replacement=\"\",x) # sub uses regular expression \n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n\n                                        # to replace part of a charachter string\ngrep(pattern=\"10\",x) # grep returns the position of the matched pattern\n\n[1] 10\n\n\n\n\n\nSelecting vectors\nSometimes, it is really useful to make a selection of your data in order to reduce computing time and complexity. In a vector, you can use the [ ] to select specific columns and rows.\n\n\n\n1.5.2 factor\n\nA factor is a vector that stores categorical data\nA factor takes the following arguments: factor(x, levels = sort(unique(x), na.last = TRUE),labels = levels, exclude = NA, ordered = is.ordered(x))\n\n\nx &lt;- factor(paste(\"fac\",x[],sep=\"\"));x\n\n [1] facvar_1  facvar_2  facvar_3  facvar_4  facvar_5  facvar_6  facvar_7 \n [8] facvar_8  facvar_9  facvar_10\n10 Levels: facvar_1 facvar_10 facvar_2 facvar_3 facvar_4 facvar_5 ... facvar_9\n\ntable(x) # Frequency table\n\nx\n facvar_1 facvar_10  facvar_2  facvar_3  facvar_4  facvar_5  facvar_6  facvar_7 \n        1         1         1         1         1         1         1         1 \n facvar_8  facvar_9 \n        1         1 \n\n# factors can be ordered\nordered(c(\"two\",\"two\",\"one\",\"three\"),levels=c(\"one\",\"two\",\"three\"))\n\n[1] two   two   one   three\nLevels: one &lt; two &lt; three\n\n\n\n\n1.5.3 Matrixes\n\narray and matrix objects are multi–dimensional generalization of vectors\na matrix has the following arguments: matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,       dimnames = NULL)\n\n\nx &lt;- matrix(data=1:10,ncol=2,nrow=5);x # by default matrix cells are filled by column. \n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5   10\n\n                                       # Use byrow=T to change the behavior\ndim(x) # gives the dimension of an array\n\n[1] 5 2\n\ndimnames(x) &lt;- list(paste(\"X\",1:5,sep=\"\"),c(\"A\",\"B\"));x# dimnames (as well as colnames and rownames) defines\n\n   A  B\nX1 1  6\nX2 2  7\nX3 3  8\nX4 4  9\nX5 5 10\n\n                                                      #the name of the matrix dimension\nx &lt;- array(data=1:12,dim=c(2,3,2)) ;x\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\nx &lt;- array(data=1:5,dim=c(2,3,2));x # this works even though the number of data inputs is different\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    1\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    2    4    1\n[2,]    3    5    2\n\n                                    #than the number of cells! This is known as the *recycling* rule\n\n\narray and matrix are indexed with the [ function and , is used to select/separate dimensions\n\n\nx[1,,2] # first row, all the columns, second matrix of the array\n\n[1] 2 4 1\n\n\n\n\n\n1.5.4 list\n\nA list is a vector for which the elements or components can be of different mode\nThe list function have the form: list(name_1=object_1,name2=object_2,...,name_n=object_n)\nUse [[ or $ operators to index a list\n\n\nx &lt;-list(alphabet = LETTERS,numbers=1:length(LETTERS),\n         mat = matrix(ncol=10,nrow=10),ls = list(vec = 1:10));x # you can have a list inside a list ...\n\n$alphabet\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\n$mat\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [5,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n[10,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n\n$ls\n$ls$vec\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx[[\"alphabet\"]]\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nx$alphabet # this is the same\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nx[[4]][[1]] # one can also extract components using their position in the list,\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n            # useful when the components of the list do not have a name\nx[1:2] # to extract several components, use only one [ \n\n$alphabet\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\nx &lt;- c(x,x) # list can be concatenated with the `c` function\n\n\n\n1.5.5 Dataframes (important!)\nDataframes are your best-friend and they are basically used as data tables providing you informations that could be number, character etc.\n\n\n\n\n\n\nAccess available Dataframes\nA lot of ready to use datasets are available in R. You can use this dataset to practice or to test your own functions. Have a look to the datasets available using data().\n\ndata(\"mtcars\")\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nstr(mtcars)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\nls() ## check the objective in the working environment\n\n[1] \"mtcars\"          \"my_vector\"       \"pandoc_dir\"      \"quarto_bin_path\"\n[5] \"R_HOME\"          \"v\"               \"x\"              \n\n\n\n\nSubsetting example\nLet’s have a practical example of subsetting. We will see here three main methods.\n\nmtcars[1,]\n\n          mpg cyl disp  hp drat   wt  qsec vs am gear carb\nMazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\nmtcars[,1]\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\n#1 classic\nmtcars[which(mtcars$wt&gt;3),]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n\n#2 with fuctions\nsubset(mtcars, wt &gt;3)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n\nsubset(mtcars, wt &gt;3, select = gear)\n\n                    gear\nHornet 4 Drive         3\nHornet Sportabout      3\nValiant                3\nDuster 360             3\nMerc 240D              4\nMerc 230               4\nMerc 280               4\nMerc 280C              4\nMerc 450SE             3\nMerc 450SL             3\nMerc 450SLC            3\nCadillac Fleetwood     3\nLincoln Continental    3\nChrysler Imperial      3\nDodge Challenger       3\nAMC Javelin            3\nCamaro Z28             3\nPontiac Firebird       3\nFord Pantera L         5\nMaserati Bora          5"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#write-and-read-data",
    "href": "R Basics/LGEO2185_IntroductionR.html#write-and-read-data",
    "title": "LGEO2185: Introduction To R",
    "section": "1.6 Write and read data",
    "text": "1.6 Write and read data\n\nwrite.csv(mtcars, \"my_mtcars.csv\")## write to your working directory \nlist.files()\n\n [1] \"_brand.yml\"          \"_quarto.yml\"         \"2025\"               \n [4] \"biblio.bib\"          \"docs\"                \"index.qmd\"          \n [7] \"logos\"               \"my_mtcars.csv\"       \"PPT600_SC_16x9.potx\"\n[10] \"PPT600_SC_16x9.pptx\" \"R Basics\"            \"README.md\"          \n[13] \"styles.css\"         \n\n\nThe most common way to read in spread sheet tables is with the read.csv() command. Type ?read.table in your R console to find out more about other formats.\n\nhp.data&lt;-read.csv(\"my_mtcars.csv\") ## read from your working directory\n\n# this is how to delete the data \nunlink(\"my_mtcars.csv\")\n\nR has a way of storing data in an object called a data frame. Consider this as an internal spreadsheet where all the relevant data items are stored. Run the line of code below, which loads a CSV file from my dropbox into a variable called hp.data\n\nclass(hp.data)\n\n[1] \"data.frame\"\n\n\nIt is always good to check if the data came in ok. You can do this by previewing the dataset with the head() function:\n\nhead(hp.data)\n\n                  X  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nNote that you can also click in the Environment window, which will show the data in a new tab, or use the command\n\nView(hp.data)\n\nUse the summary() function to explore basic statistics of your dataset.\nWe can use square brackets to look at specific sections of the data frame, for example hp.data[1,] or hp.data[,1]. We can also delete columns and create new columns using the code below. Remember to use the head() command as we did earlier to look at the data frame.\n\n#create a new column in hp.data dataframe call counciltax, storing the value NA\nhp.data$counciltax &lt;- NA\n#see what has happened\nhead(hp.data)\n\n                  X  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n  counciltax\n1         NA\n2         NA\n3         NA\n4         NA\n5         NA\n6         NA\n\n\n\n#delete a column\n hp.data$counciltax &lt;- NULL\n#see what has happened\nhead(hp.data)\n\n                  X  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n#rename a column\ncolnames (hp.data)[1] &lt;- \"mpg2\"\n#see what has happened\nhead(hp.data)\n\n               mpg2  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nNow is a good time to remind you to save your data on a regular basis. This is particularly important if you are working on a project, and need to reload your data later on. R has a number of different elements you can save. The workspace is the most important element, as it contains any data frames or other objects you have created; i.e. everything listed in the Environment tab, like the hp.data object we created earlier. To do this, click the save button in the Environment tab. Choose somewhere to save it (your Documents folder is a good place) and give it a name. To load these in a new session, click File &gt; Open File and select your file."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#computing-on-data",
    "href": "R Basics/LGEO2185_IntroductionR.html#computing-on-data",
    "title": "LGEO2185: Introduction To R",
    "section": "1.7 Computing on data",
    "text": "1.7 Computing on data\n\nIn R, a lot of computation can be realised in a vectorized form. No need for loops!\nAn operation on a vector of values works the same as it would do on a single value.\n\n\n# Compute the square of a vector in a traditional way\nX &lt;- 1:10\nsqX &lt;- numeric(length(X))\nfor(i in 1:length(sqX)){\n  sqX[i] &lt;- (X[i])^2  \n}\nsqX\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n# while it would have been much simpler (and faster) to write\nsqX &lt;- X^2\nmatrix(1:10,nrow=5,ncol=2)^2 # a given operation works often\n\n     [,1] [,2]\n[1,]    1   36\n[2,]    4   49\n[3,]    9   64\n[4,]   16   81\n[5,]   25  100\n\n                             #the same way for different data structure!\n\n\ncolSums, rowSums, colMeans, rowMeans allow to compute row and column sums and means of numeric arrays\n\n\ncolMeans(matrix(rnorm(100),ncol=10))\n\n [1]  0.2366138 -0.1845166 -0.1895069  0.1988200  0.3697124 -0.1626034\n [7]  0.3122586  0.3360583  0.3761269 -0.1880275\n\nrowSums(matrix(rnorm(100),ncol=10))\n\n [1] -1.5567120 -3.5652321  3.0747219 -0.3937206 -1.4292293  1.4255957\n [7]  1.0901836  1.7274019 -0.7398516 -4.2832666"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#if..else",
    "href": "R Basics/LGEO2185_IntroductionR.html#if..else",
    "title": "LGEO2185: Introduction To R",
    "section": "2.1 if..else",
    "text": "2.1 if..else\nThe basic syntax for creating an if..else statement in R is\n\nif(boolean_expression) {\n   // statement(s) will execute if the boolean expression is true.\n} else {\n   // statement(s) will execute if the boolean expression is false.\n}\n\n\n#let's generate some random numbers\nrand_data &lt;- rnorm(100, mean=0, sd=10)\n#it is now easy to plot a histogram of this vector:\nhist(rand_data)\n\n\n\n\n\n\n\n#Now, let us try to usean  if then statement\nif (mean(rand_data)&lt;0) {\n   print(\"The mean is below 0\")\n} else {\n   print(\"The mean is equal to or higher than 0\")\n}\n\n[1] \"The mean is below 0\"\n\n\nHave a look at the different operators that are available."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#iteration-and-looping",
    "href": "R Basics/LGEO2185_IntroductionR.html#iteration-and-looping",
    "title": "LGEO2185: Introduction To R",
    "section": "2.2 Iteration and looping",
    "text": "2.2 Iteration and looping\nYou can also do something for all items in a vector or list.\n\na_vector &lt;- c(-10:10)\nfor (item in a_vector) {\n  print(item)\n}\n\n\n\n\n\n\n\nNote\n\n\n\n\nThere are other constructions possible (e.g. while, until, repeat …)\nHave a look also to the functions of the *apply family.\n\nSome examples below…\n\n# lapply function applies a function\n# to each element of X (being a vector or a list). \n# Remember that a data.frame is a special case of a list\nlapply(X=iris[,1:4],FUN=mean) \n\n$Sepal.Length\n[1] 5.843333\n\n$Sepal.Width\n[1] 3.057333\n\n$Petal.Length\n[1] 3.758\n\n$Petal.Width\n[1] 1.199333\n\n# sapply works the same way but returns the results nicely (if possible)\nsapply(X=iris[,1:4],FUN=mean) \n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.843333     3.057333     3.758000     1.199333 \n\n# Compute the median of the first 10 rows of the iris dataset\napply(X=iris[1:10,1:4],MARGIN=1,FUN=median) \n\n   1    2    3    4    5    6    7    8    9   10 \n2.45 2.20 2.25 2.30 2.50 2.80 2.40 2.45 2.15 2.30 \n\n# Compute the median of the first variable for each level of\n# the 5th variable. Note that X is a vector\ntapply(X=iris[,1],INDEX=iris[,5],FUN=median)  \n\n    setosa versicolor  virginica \n       5.0        5.9        6.5 \n\n# same as tapply but works on data.frames\nby(data=iris[,1:4],INDICES=iris[,5],FUN=mean) \n\niris[, 5]: setosa\n[1] NA\n------------------------------------------------------------ \niris[, 5]: versicolor\n[1] NA\n------------------------------------------------------------ \niris[, 5]: virginica\n[1] NA\n\n# idem\naggregate(x=iris[,1:4],by=list(Species=iris[,5]),FUN=mean)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026"
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#functions",
    "href": "R Basics/LGEO2185_IntroductionR.html#functions",
    "title": "LGEO2185: Introduction To R",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nOne of the great strengths of R is the user’s ability to add functions. In fact, many of the functions in R are actually functions of functions. The structure of a function is given below.\n\nmyfunction &lt;- function(arg1, arg2, ... ){\n  statements\n  return(object)\n}\n\nAn example:\n\nmy_multiply_function &lt;- function(base, multiplier){\nz &lt;- base*multiplier\nreturn(z)\n}\n#now lets use this simple function\nmy_multiply_function(5,5)\n\n[1] 25\n\n\nNice! Now it’s your turn:\n\nWrite your own function that calculates the sum of squares of two numbers\nCheck your function to evaluate the SS of 3 and 4, the answer is 25, right? Note that you give a name to the arguments when you define the function and you can use the arguments name in the commands section of the function.\nA function can return anything you want, a number, a list, a dataframe, nothing…\nWrite a function that calculates z=2*x+y, and returns a vector (z,x,y).\n\nYou can define a function in the same script as your code but you can also save your function as a separate R-file. Copy your sum of squares function into a new R-script (File -&gt; New File -&gt; R-script) and give it the same name as your function. You can now use the source() function to load your function from a file. The function is now available throughout your session!\n\nsource(\"sum_of_squares.R\")\n\nFrom the point of view of writing nice code, this approach is useful because it leaves you with an uncluttered analysis script, and a repository of useful functions that can be loaded into any analysis script in your project. It also lets you group related functions together easily.\n\n\n\n\n\n\nNote\n\n\n\nThe special argument ... (pronounced “dot-dot-dot”) is used to capture any number of additional arguments that are passed to a function. It is often used to forward arguments to another function. For example, you can create a wrapper function around a base function and allow users to pass additional parameters:\n\nmy_plot &lt;- function(x, y, ...) {\n  plot(x, y, ...)\n}\n\nHere, the ... will accept any extra parameters (e.g., col, pch, main) and forward them to the plot() function."
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#assignment",
    "href": "R Basics/LGEO2185_IntroductionR.html#assignment",
    "title": "LGEO2185: Introduction To R",
    "section": "Assignment",
    "text": "Assignment\n\nRead this introduction about R functions\nCreate an R script, where you plot the mean, drawn from a normal distribution as function of the sample size. You should use the following elements: rnorm() function, matrix(), plot(), for {}. Make a function where the user can change the sample size considered, and the variables of the normal distribution. Bonus: do not use any for loops"
  }
]