[
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#understanding-spatial-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#understanding-spatial-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "Understanding spatial data",
    "text": "Understanding spatial data\nSpatial phenomena generally fall into two categories:\n\nDiscrete Objects:\nThese are objects with clear boundaries, such as rivers, roads, countries, towns, or research sites.\nContinuous Phenomena (Spatial Fields):\nThese are variables that can be observed across an area without natural boundaries, such as elevation, temperature, or air quality.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#representing-spatial-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#representing-spatial-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "Representing spatial data",
    "text": "Representing spatial data\n\nVector Data:\nDiscrete spatial objects are typically represented as vector data. This data type consists of:\n\nGeometry: The “shape” or spatial outline of the object.\nAttributes: Additional information associated with the object.\nExample: A vector dataset might include the borders of countries (geometry) along with their names and population sizes (attributes).\n\nRaster Data:\nContinuous spatial phenomena are usually represented with raster data structures.\n\nIn the sections that follow, we will delve into these two data types and demonstrate how to manipulate them using R and the terra package.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "1.1 Vector data",
    "text": "1.1 Vector data\nVector data represents spatial features using geometries composed of coordinate pairs (x, y). The primary vector data types are points, lines, and polygons.\n\n\n\nDifferent type of vector data (@lovelace_geocomputation_2025)\n\n\n\nPoints\n\nDefinition:\nA point is the simplest vector type, represented by a single coordinate pair.\nAttributes:\nPoints are often associated with several variables. For example, a point might indicate where a rat was trapped, with attributes such as the capture date, the person who captured it, species details, size, sex, and habitat information.\nMultipoint Structures:\nMultiple points can be combined into a single multipoint geometry that shares one attribute record. For example, all coffee shops in a town might be represented as a single multipoint structure.\n\n\n\nLines\n\nDefinition:\nA “line” refers to one or more polylines—a connected series of line segments.\nGeometry:\nLines are represented as ordered sets of coordinates (nodes). The order is crucial, as it dictates how the points are connected to form the line segments.\nExamples:\nA river and its tributaries can be treated as a single line or as separate lines (one for each tributary), depending on the analysis.\nNetworks (Spatial Graphs):\nA network, such as a road or river network, is a specialized type of line geometry. It includes additional information about flow, connectivity, direction, and distance.\n\n\n\nPolygons\n\nDefinition:\nA polygon consists of one or more closed polylines. To form a closed shape, the last coordinate pair of a polygon is the same as the first.\nGeometry and rules:\n\nClosed Shape: The geometry of a polygon requires closure, meaning the sequence of coordinates must return to the starting point.\nHoles: Polygons can contain holes—areas entirely enclosed by the polygon that are excluded from the fill. An example is an island within a lake.\nValidity: For a polygon to be valid, it must not self-intersect (unlike lines, which can cross themselves).\n\nMultipolygon structures:\nMultiple polygons can be treated as a single geometry. For instance, a country like Indonesia, comprised of many islands, may be represented as a multipolygon, where each island is an individual polygon within the larger structure.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#raster-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#raster-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "1.2 Raster data",
    "text": "1.2 Raster data\nRaster data is commonly used to represent spatially continuous phenomena, such as elevation. Instead of storing explicit geometries like vector data, a raster divides the world into a grid of equally sized rectangular cells (often called cells or pixels in satellite remote sensing). Each cell holds one or more values (or possibly missing values) corresponding to the variable(s) of interest.\n\nKey Characteristics\n\nGrid structure:\nThe world is divided into a regular grid of cells. Each cell covers a specific, uniform area.\nCell values:\n\nTypically, a cell value represents the average or majority value for the area it covers.\nIn some cases, the cell value is an estimate at the center of the cell, essentially treating the grid as a set of regularly spaced points with attributes.\n\nImplicit geometry:\nUnlike vector data, raster data does not store coordinates for each cell explicitly. Instead, the geometry is defined by:\n\nThe spatial extent (boundaries) of the dataset.\nThe number of rows and columns in the grid.\nFrom these, the size of each cell (i.e., the spatial resolution) can be computed.\n\nEfficiency consideration:\nRepresenting each cell as an explicit polygon with its own coordinates would be inefficient. Not only would this increase storage requirements, but it would also significantly slow down data processing.\nTriangulated Irregular Networks (TINs):\nAlthough continuous surface data can also be represented using TINs, which consist of irregularly spaced triangles, this method is not covered in the current discussion.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#representation-of-spatial-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#representation-of-spatial-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "1.3 Representation of spatial data",
    "text": "1.3 Representation of spatial data\nThe basic data types in R are numbers, characters, logical (TRUE or FALSE) and factor values.\nValues of a single type can be combined in vectors and matrices, and variables of multiple types can be combined into a data.frame. We can represent (only very) basic spatial data with these data types. Let’s say we have the location (represented by longitude and latitude) of ten weather stations (named A to J) and their annual precipitation.\nIn the example below we make a very simple map. Note that a map is special type of plot (like a scatter plot, barplot, etc.). A map is a plot of geospatial data that also has labels and other graphical objects such as a scale bar or legend. The spatial data itself should not be referred to as a map.\n\nname &lt;- LETTERS[1:10]\nlongitude &lt;- c(\n    -116.7, -120.4, -116.7, -113.5, -115.5,\n    -120.8, -119.5, -113.7, -113.7, -110.7\n)\nlatitude &lt;- c(\n    45.3, 42.6, 38.9, 42.1, 35.7, 38.9,\n    36.2, 39, 41.6, 36.9\n)\nstations &lt;- cbind(longitude, latitude)\n# Simulated rainfall data\nset.seed(0)\nprecip &lt;- round((runif(length(latitude)) * 10)^3)\n\nA map of point locations is not that different from a basic x-y scatter plot. Here I make a plot (a map in this case) that shows the location of the weather stations, and the size of the dots is proportional to the amount of precipitation. The point size is set with argument cex.\n\npsize &lt;- 1 + precip / 500\nplot(stations, cex = psize, pch = 20, col = \"red\", main = \"Precipitation\")\n# add names to plot\ntext(stations, name, pos = 4)\n# add a legend\nbreaks &lt;- c(100, 250, 500, 1000)\nlegend.psize &lt;- 1 + breaks / 500\nlegend(\"topright\", legend = breaks, pch = 20, pt.cex = legend.psize, col = \"red\", bg = \"gray\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe data are represented by “longitude, latitude”, in that order, do not use “latitude, longitude” because on most maps latitude (North/South) is used for the vertical axis and longitude (East/West) for the horizontal axis. This is important to keep in mind, as it is a very common source of mistakes!\n\n\nWe can add multiple sets of points to the plot, and even draw lines and polygons:\n\nlon &lt;- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)\nlat &lt;- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)\nx &lt;- cbind(lon, lat)\nplot(stations, main = \"Precipitation\")\npolygon(x, col = \"blue\", border = \"light blue\")\nlines(stations, lwd = 3, col = \"red\")\npoints(x, cex = 2, pch = 20)\npoints(stations, cex = psize, pch = 20, col = \"red\", main = \"Precipitation\")\n\n\n\n\n\n\n\n\nThe above illustrates how numeric vectors representing locations can be used to draw simple maps. It also shows how points can (and typically are) represented by pairs of numbers. A line and a polygon can be represented by a number of these points. Polygons need to “closed”, that is, the first point must coincide with the last point, but the polygon function took care of that for us.\nThere are cases where a simple approach like this may suffice and you may come across this in older R code or packages. Likewise, raster data could be represented by a matrix or higher-order array. Particularly when only dealing with point data such an approach may be practical. For example, a spatial data set representing points and attributes could be made by combining geometry and attributes in a single data.frame.\n\nwst &lt;- data.frame(longitude, latitude, name, precip)\nwst\n\n   longitude latitude name precip\n1     -116.7     45.3    A    721\n2     -120.4     42.6    B     19\n3     -116.7     38.9    C     52\n4     -113.5     42.1    D    188\n5     -115.5     35.7    E    749\n6     -120.8     38.9    F      8\n7     -119.5     36.2    G    725\n8     -113.7     39.0    H    843\n9     -113.7     41.6    I    289\n10    -110.7     36.9    J    249\n\n\nHowever, wst is a data.frame and R does not automatically understand the special meaning of the first two columns, or to what coordinate reference system it refers (longitude/latitude, or perhaps UTM zone 17S, or ….?).\nMoreover, it is non-trivial to do some basic spatial operations. For example, the blue polygon drawn on the map above might represent a state, and a next question might be which of the 10 stations fall within that polygon. And how about any other operation on spatial data, including reading from and writing data to files? To facilitate such operation a number of R packages have been developed that define new spatial data types that can be used for this type of specialized operations.\nRecent packages in R that define such spatial data structures include terra and sf. These packages replace a set of older packages including raster and sp.\nWe will mostly use the terra and sf package in these course. You can install the latest released version of terra and sf from CRAN with install.packages(\"terra\") and install.packages(\"sf\").",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-1",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-1",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "2.1. Introduction",
    "text": "2.1. Introduction\nThe terra package defines a set of classes to represent spatial data. A class defines a particular data type. The data.frame is an example of a class. Any particular data.frame you create is an object (instantiation) of that class.\nThe main reason for defining classes is to create a standard representation of a particular data type to make it easier to write functions (known as “methods”) for them. See @wickham2019 or @chambers2008 for a detailed discussion of the use of classes in R.\nterra introduces a number of classes with names that start with Spat. For vector data, the relevant class is SpatVector. These classes represent geometries as well as attributes (variables) describing the geometries.\nIt is possible to create SpatVector objects from scratch with R code. This is very useful when creating a small self contained example to illustrate something, for example to ask a question about how to do a particular operation; without needing to give access to the real data you are using (which is always cumbersome). It is also frequently done when using coordinates that were obtained with a GPS. But in most other cases, you will read these from a file or database.\nTo get started, let’s make some SpatVector objects from scratch anyway, using the same data as were used in the previous chapter.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#points-1",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#points-1",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "2.2 Points",
    "text": "2.2 Points\n\nlongitude &lt;- c(-116.7, -120.4, -116.7, -113.5, -115.5, -120.8, -119.5, -113.7, -113.7, -110.7)\nlatitude &lt;- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9, 36.2, 39, 41.6, 36.9)\nlonlat &lt;- cbind(longitude, latitude)\n\nNow create a SpatVector object. First load the terra package from the library. If this command fails with Error in library(terra) : there is no package called ‘terra’, then you need to install the package first, with install.packages(\"terra\")\n\nlibrary(terra)\npts &lt;- vect(lonlat)\n\nLet’s check what kind of object pts is.\n\nclass(pts)\n\n[1] \"SpatVector\"\nattr(,\"package\")\n[1] \"terra\"\n\n\nAnd what is inside of it\n\npts\n\n class       : SpatVector \n geometry    : points \n dimensions  : 10, 0  (geometries, attributes)\n extent      : -120.8, -110.7, 35.7, 45.3  (xmin, xmax, ymin, ymax)\n coord. ref. :  \n\ngeom(pts)\n\n      geom part      x    y hole\n [1,]    1    1 -116.7 45.3    0\n [2,]    2    1 -120.4 42.6    0\n [3,]    3    1 -116.7 38.9    0\n [4,]    4    1 -113.5 42.1    0\n [5,]    5    1 -115.5 35.7    0\n [6,]    6    1 -120.8 38.9    0\n [7,]    7    1 -119.5 36.2    0\n [8,]    8    1 -113.7 39.0    0\n [9,]    9    1 -113.7 41.6    0\n[10,]   10    1 -110.7 36.9    0\n\n\nSo we see that the object has the coordinates we supplied, but also an extent. This spatial extent was computed from the coordinates. There is also a coordinate reference system (“CRS”, discussed in more detail later). We did not provide the CRS when we created pts. That is not good, so let’s recreate the object, and now provide a CRS.\n\ncrdref &lt;- \"+proj=longlat +datum=WGS84\"\npts &lt;- vect(lonlat, crs = crdref)\npts\n\n class       : SpatVector \n geometry    : points \n dimensions  : 10, 0  (geometries, attributes)\n extent      : -120.8, -110.7, 35.7, 45.3  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n\ncrs(pts)\n\n[1] \"GEOGCRS[\\\"unknown\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ID[\\\"EPSG\\\",6326]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n        ID[\\\"EPSG\\\",8901]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"longitude\\\",east,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433,\\n                ID[\\\"EPSG\\\",9122]]],\\n        AXIS[\\\"latitude\\\",north,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433,\\n                ID[\\\"EPSG\\\",9122]]]]\"\n\n\nWe can add attributes (variables) to the SpatVector object. First we need a data.frame with the same number of rows as there are geometries.\n\n# Generate random precipitation values, same quantity as points\nprecipvalue &lt;- runif(nrow(lonlat), min = 0, max = 100)\ndf &lt;- data.frame(ID = 1:nrow(lonlat), precip = precipvalue)\n\nCombine the SpatVector with the data.frame.\n\nptv &lt;- vect(lonlat, atts = df, crs = crdref)\n\nTo see what is inside:\n\nptv\n\n class       : SpatVector \n geometry    : points \n dimensions  : 10, 2  (geometries, attributes)\n extent      : -120.8, -110.7, 35.7, 45.3  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n names       :    ID precip\n type        : &lt;int&gt;  &lt;num&gt;\n values      :     1  6.179\n                   2   20.6\n                   3  17.66",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#lines-and-polygons",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#lines-and-polygons",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "2.3 Lines and polygons",
    "text": "2.3 Lines and polygons\nMaking a SpatVector of points was easy. Making a SpatVector of lines or polygons is a bit more complex, but stil relatively straightforward.\n\nlon &lt;- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)\nlat &lt;- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)\nlonlat &lt;- cbind(id = 1, part = 1, lon, lat)\nlonlat\n\n     id part    lon  lat\n[1,]  1    1 -116.8 41.3\n[2,]  1    1 -114.2 42.9\n[3,]  1    1 -112.9 42.4\n[4,]  1    1 -111.9 39.8\n[5,]  1    1 -114.2 37.6\n[6,]  1    1 -115.4 38.3\n[7,]  1    1 -117.7 37.6\n\nlns &lt;- vect(lonlat, type = \"lines\", crs = crdref)\nlns\n\n class       : SpatVector \n geometry    : lines \n dimensions  : 1, 0  (geometries, attributes)\n extent      : -117.7, -111.9, 37.6, 42.9  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n\n\n\npols &lt;- vect(lonlat, type = \"polygons\", crs = crdref)\npols\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 1, 0  (geometries, attributes)\n extent      : -117.7, -111.9, 37.6, 42.9  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n\n\nBehind the scenes the class deals with the complexity of accommodating for the possibility of multiple polygons, each consisting of multiple sub-polygons, some of which may be “holes”. You do not need to understand how these structures are organized. The main take home message is that a SpatVector stores geometries (coordinates), the name of the coordinate reference system, and attributes.\nWe can make use plot to make a map.\n\nplot(pols, las = 1)\nplot(pols, border = \"blue\", col = \"yellow\", lwd = 3, add = TRUE)\npoints(pts, col = \"red\", pch = 20, cex = 3)\n\n\n\n\n\n\n\n\nWe’ll make more fancy maps, see below !!!!",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-2",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-2",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "3.1. Introduction",
    "text": "3.1. Introduction\nThe sf package provides a simple and consistent framework for working with spatial vector data in R. It is based on the concept of simple features as standardized by the Open Geospatial Consortium (OGC). Simple features are geometric objects that can represent points, lines, polygons, and their combinations.\nThe primary class in sf for working with vector data is sf (simple features). An sf object is essentially a data frame that includes special columns for geometric data, making it easy to manipulate attributes and geometries together. This design aligns with the tidy data principles popularized in the R ecosystem.\nFor a more in-depth exploration of the concepts behind sf, refer to the official sf documentation",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#points-2",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#points-2",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "3.2. Points",
    "text": "3.2. Points\nLet’s start by creating a set of points using the sf package. If you haven’t already installed sf, you can do so using install.packages(\"sf\").\n\n# Load the sf package\nlibrary(sf)\n\n# Create a simple data frame with coordinates\ndata &lt;- data.frame(ID = 1:length(lon), lon, lat)\n\n# Convert to an sf object\npoints_sf &lt;- st_as_sf(data, coords = c(\"lon\", \"lat\"), crs = 4326) # crs is the projection system (here, WGS84, we will see this later)\n\n# Inspect the structure\nclass(points_sf)\n\n[1] \"sf\"         \"data.frame\"\n\npoints_sf\n\nSimple feature collection with 7 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -117.7 ymin: 37.6 xmax: -111.9 ymax: 42.9\nGeodetic CRS:  WGS 84\n  ID            geometry\n1  1 POINT (-116.8 41.3)\n2  2 POINT (-114.2 42.9)\n3  3 POINT (-112.9 42.4)\n4  4 POINT (-111.9 39.8)\n5  5 POINT (-114.2 37.6)\n6  6 POINT (-115.4 38.3)\n7  7 POINT (-117.7 37.6)\n\n\nHere, the st_as_sf function converts the data frame into an sf object, specifying the coordinate columns and the CRS (EPSG:4326 corresponds to WGS84). Let’s visualize the points:\n\n# Plot the points\nplot(points_sf, col = \"blue\", pch = 20, cex = 1.5)",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#lines-and-polygons-1",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#lines-and-polygons-1",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "3.3. Lines and Polygons",
    "text": "3.3. Lines and Polygons\nSimilar to points, lines and polygons can also be created using sf. Let’s first define a set of coordinates and then convert them into geometries.\n\n# Define coordinates for a line\nline_coords &lt;- matrix(\n    c(\n        -116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7,\n        41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6\n    ),\n    ncol = 2, byrow = FALSE\n)\n\n# Create a line geometry\nline_sf &lt;- st_sfc(st_linestring(line_coords), crs = 4326)\nline_sf\n\nGeometry set for 1 feature \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: -117.7 ymin: 37.6 xmax: -111.9 ymax: 42.9\nGeodetic CRS:  WGS 84\n\n\nFor polygons, a similar process can be followed:\n\n# Define coordinates for a polygon\npolygon_coords &lt;- matrix(\n    c(\n        -116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7, -116.8,\n        41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6, 41.3\n    ),\n    ncol = 2, byrow = FALSE\n)\n\n# Create a polygon geometry\npolygon_sf &lt;- st_sfc(st_polygon(list(polygon_coords)), crs = 4326)\npolygon_sf\n\nGeometry set for 1 feature \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -117.7 ymin: 37.6 xmax: -111.9 ymax: 42.9\nGeodetic CRS:  WGS 84\n\n\nThe sf package simplifies the complexity of geometric structures while adhering to standards. Additionally, it allows plotting and combining geometries seamlessly with attribute data.\n\n# Plot the polygon with the line and points\nplot(polygon_sf, col = \"yellow\", border = \"blue\", lwd = 2)\nplot(line_sf, col = \"red\", lwd = 2, add = TRUE)\nplot(points_sf, col = \"green\", pch = 20, cex = 1.5, add = TRUE)",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-3",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-3",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "4.1 Introduction",
    "text": "4.1 Introduction\nThe terra package has functions for creating, reading, manipulating, and writing raster data. The package provides, among other things, general raster data manipulation functions that can easily be used to develop more specific functions. For example, there are functions to read a chunk of raster values from a file or to convert cell numbers to coordinates and back. The package also implements raster algebra and many other functions for raster data manipulation.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#spatraster",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#spatraster",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "4.2 SpatRaster",
    "text": "4.2 SpatRaster\nA SpatRaster represents multi-layer (multi-variable) raster data. A SpatRaster always stores a number of fundamental parameters describing its geometry. These include the number of columns and rows, the spatial extent, and the Coordinate Reference System. In addition, a SpatRaster can store information about the file in which the raster cell values are stored. Or, if there is no such a file, a SpatRaster can hold the cell values in memory.\nHere I create a SpatRaster from scratch. But note that in most cases where real data is analyzed, these objects are created from a file.\n\nlibrary(terra)\nr &lt;- rast(ncol = 10, nrow = 10, xmin = -150, xmax = -80, ymin = 20, ymax = 60)\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n\n\nSpatRaster r only has the geometry of a raster data set. That is, it knows about its location, resolution, etc., but there are no values associated with it. Let’s assign some values. In this case I assign a vector of random numbers with a length that is equal to the number of raster cells.\n\nvalues(r) &lt;- runif(ncell(r))\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        :      lyr.1 \nmin value   : 0.01307758 \nmax value   : 0.99268406 \n\n\nYou could also assign cell numbers (in this case overwriting the previous values)\n\nvalues(r) &lt;- 1:ncell(r)\nr\n\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        : lyr.1 \nmin value   :     1 \nmax value   :   100 \n\n\nWe can plot this object.\n\nplot(r)\n# add polygon and points\nlon &lt;- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)\nlat &lt;- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)\nlonlat &lt;- cbind(id = 1, part = 1, lon, lat)\npts &lt;- vect(lonlat)\npols &lt;- vect(lonlat, type = \"polygons\", crs = \"+proj=longlat +datum=WGS84\")\npoints(pts, col = \"red\", pch = 20, cex = 3)\nlines(pols, col = \"blue\", lwd = 2)\n\n\n\n\n\n\n\n\nYou can create a multi-layer object using the c method.\n\nr2 &lt;- r * r\nr3 &lt;- sqrt(r)\ns &lt;- c(r, r2, r3)\ns\n\nclass       : SpatRaster \nsize        : 10, 10, 3  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nnames       : lyr.1, lyr.1, lyr.1 \nmin values  :     1,     1,     1 \nmax values  :   100, 10000,    10",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#spatrasterdataset",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#spatrasterdataset",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "4.3 SpatRasterDataset",
    "text": "4.3 SpatRasterDataset\nA SpatRasterDataset is a collection of SpatRaster objects, often representing different layers or time series data. This is particularly useful when working with multi-band raster files or datasets stored in multiple files.\n\n\n[1] 3 3 3",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-4",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-4",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "5.1 Introduction",
    "text": "5.1 Introduction\nReading and writing spatial data is complicated by the fact that there are many different file formats. However, there are a few formats that are most common that we discuss here.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-files",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-files",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "5.2 Vector files",
    "text": "5.2 Vector files\nThe shapefile is the most commonly used file format for vector data (if you are not familiar with this file format, an important thing to understand is that a shapefile is really a set of at least three (ideally four) files, with all the same name, but different extension. For shapefile x you must have, in the same directory, these three files: x.shp, x.shx, x.dbf, and ideally also x.prj.\nIt is easy to read and write such files. Here we use a shapefile that you can download from the Teams channel under the /data folder (you should put this data files into your current working directory).\n\nReading\n\nfilename &lt;- \"data/France.shp\"\n\nNow we have the filename we can use the vect function to read the file.\n\ns &lt;- vect(filename)\ns\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 13  (geometries, attributes)\n extent      : -5.143751, 9.560416, 41.33375, 51.0894  (xmin, xmax, ymin, ymax)\n source      : France.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :     GID_2 GID_0 COUNTRY   GID_1          NAME_1 NL_NAME_1\n type        :     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;     &lt;chr&gt;\n values      : FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n  NAME_2    VARNAME_2 NL_NAME_2      TYPE_2 (and 3 more)\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n     Ain           NA        NA Département             \n  Allier Basses-Alpes        NA Département             \n Ardèche           NA        NA Département             \n\n# using sf is as easy\ns_sf &lt;- st_read(filename)\n\nReading layer `France' from data source \n  `/Users/Antoine_Stevens/Library/CloudStorage/OneDrive-McKinsey&Company/Documents/Projects/LGEO/Intro to Spatial Data/data/France.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 96 features and 13 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -5.143751 ymin: 41.33375 xmax: 9.560416 ymax: 51.0894\nGeodetic CRS:  WGS 84\n\ns_sf\n\nSimple feature collection with 96 features and 13 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -5.143751 ymin: 41.33375 xmax: 9.560416 ymax: 51.0894\nGeodetic CRS:  WGS 84\nFirst 10 features:\n        GID_2 GID_0 COUNTRY   GID_1               NAME_1 NL_NAME_1       NAME_2\n1   FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;          Ain\n2   FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;       Allier\n3   FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;      Ardèche\n4   FRA.1.4_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;       Cantal\n5   FRA.1.5_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;        Drôme\n6   FRA.1.6_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;  Haute-Loire\n7   FRA.1.7_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt; Haute-Savoie\n8   FRA.1.8_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;        Isère\n9   FRA.1.9_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;        Loire\n10 FRA.1.10_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;  Puy-de-Dôme\n      VARNAME_2 NL_NAME_2      TYPE_2  ENGTYPE_2 CC_2 HASC_2\n1          &lt;NA&gt;      &lt;NA&gt; Département Department   01  FR.AI\n2  Basses-Alpes      &lt;NA&gt; Département Department   03  FR.AL\n3          &lt;NA&gt;      &lt;NA&gt; Département Department   07  FR.AH\n4          &lt;NA&gt;      &lt;NA&gt; Département Department   15  FR.CL\n5          &lt;NA&gt;      &lt;NA&gt; Département Department   26  FR.DM\n6          &lt;NA&gt;      &lt;NA&gt; Département Department   43  FR.HL\n7          &lt;NA&gt;      &lt;NA&gt; Département Department   74  FR.HS\n8          &lt;NA&gt;      &lt;NA&gt; Département Department   38  FR.IS\n9          &lt;NA&gt;      &lt;NA&gt; Département Department   42  FR.LR\n10         &lt;NA&gt;      &lt;NA&gt; Département Department   63  FR.PD\n                         geometry\n1  MULTIPOLYGON (((5.623748 45...\n2  MULTIPOLYGON (((3.678016 45...\n3  MULTIPOLYGON (((4.141665 44...\n4  MULTIPOLYGON (((3.064186 44...\n5  MULTIPOLYGON (((5.447571 44...\n6  MULTIPOLYGON (((3.829915 44...\n7  MULTIPOLYGON (((6.177382 45...\n8  MULTIPOLYGON (((5.647102 44...\n9  MULTIPOLYGON (((4.505591 45...\n10 MULTIPOLYGON (((3.291755 45...\n\n\nThe vect function returns SpatVector objects. It is important to recognise the difference between this type of R object (SpatVector), and the file (“shapefile”) that was used to create it. Thus, you should never say “I have a shapefile in R”, say “I have a SpatVector of polygons in R”, (and in some cases you can add “created from a shapefile”). The shapefile is one of many file formats for vector data.\n\n\nWriting\nYou can write new files using the writeVector method. You need to add argument overwrite=TRUE if you want to overwrite an existing file.\n\n# use geopackage rather than shapefile. you'll be able to keep column names and write only one file to disk :-)\noutfile &lt;- \"data/shp_test.gpkg\"\nwriteVector(s, outfile, overwrite = TRUE)\n\nTo remove the file again you can use file.remove or unlink (be careful!)\n\nff &lt;- list.files(\"data\", patt = \"^shp_test\", full.names = TRUE) # needed if you had many files (eg. shapefile)\nfile.remove(ff)\n\n[1] TRUE",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#raster-files",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#raster-files",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "5.3 Raster files",
    "text": "5.3 Raster files\nThe actual data used in geo processing projects often comes as geo-data, stored on files such as GeoTiff or other commonly used file formats. Reading data directly from these files into the R working environment (as SpatRaster objects ), is made possible thanks to the terra package.\n\nReading\nUse the raster files “chm_lidar.tif” and “Lubumbashi_Sentinel2.tif” which you can download in the data folder for this session: Note that “chm_lidar.tif” gives you a tree canopy height model (in m) for a forest in the DR Congo. The Sentinel2 image is a multi-band false color composite (RGB).\n\nlidar &lt;- rast(\"data/chm_lidar.tif\")\nplot(lidar)\n\n\n\n\n\n\n\n# see the col options in ?plot\nplot(lidar, col = colorRampPalette(c(\"red\", \"white\", \"blue\"))(255))\n\n\n\n\n\n\n\n\nLoad the following sentinel2 image. Note that it has 3 layers and that you can access the separate bands using the $. You can also subset a single layer (see below)\n\nLushi &lt;- rast(\"data/Lubumbashi_Sentinel2b.tif\")\nLushi\n\nclass       : SpatRaster \nsize        : 1826, 1651, 3  (nrow, ncol, nlyr)\nresolution  : 10, 10  (x, y)\nextent      : 565057.8, 581567.8, 8719019, 8737279  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 35S (EPSG:32735) \nsource      : Lubumbashi_Sentinel2b.tif \ncolors RGB  : 1, 2, 3 \nnames       : Lubumbashi~ntinel2b_1, Lubumbashi~ntinel2b_2, Lubumbashi~ntinel2b_3 \n\nplot(Lushi)\n\n\n\n\n\n\n\nplot(Lushi$Lubumbashi_Sentinel2b_1)\n\n\n\n\n\n\n\nLushi[[2]]\n\nclass       : SpatRaster \nsize        : 1826, 1651, 1  (nrow, ncol, nlyr)\nresolution  : 10, 10  (x, y)\nextent      : 565057.8, 581567.8, 8719019, 8737279  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 35S (EPSG:32735) \nsource      : Lubumbashi_Sentinel2b.tif \nname        : Lubumbashi_Sentinel2b_2 \n\n\n\n\nWriting\nUse writeRaster to write raster data. You must provide a SpatRaster and a filename. The file format will be guessed from the filename extension. If that does not work you can provide an argument like format=GTiff. Note the argument overwrite=TRUE and see ?writeRaster for more arguments, such as datatype= to set the a specific datatype (e.g., integer).\n\nwriteRaster(lidar, \"data/CHM_lidar_copy.tif\", overwrite = TRUE)",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-5",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#introduction-5",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "6.1 Introduction",
    "text": "6.1 Introduction\nA very important aspect of spatial data is the coordinate reference system (CRS) that is used. For example, a location of (140, 12) is not meaningful if you do know where the origin (0,0) is and if the x-coordinate is 140 meters, feet, nautical miles, kilometers, or perhaps degrees away from the x-origin.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#coordinate-reference-systems-crs",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#coordinate-reference-systems-crs",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "6.2 Coordinate Reference Systems (CRS)",
    "text": "6.2 Coordinate Reference Systems (CRS)\n\n6.2.1 Projections\nA major question in spatial analysis and cartography is how to transform this three dimensional angular system to a two dimensional planar (sometimes called “Cartesian”) system. A planar system is easier to use for certain calculations and required to make maps (unless you have a 3-d printer). The different types of planar coordinate reference systems are referred to as “projections”. Examples are “Mercator”, “UTM”, “Robinson”, “Lambert”, “Sinusoidal” and “Albers”.\nThere is not one best projection. Some projections can be used for a map of the whole world; other projections are appropriate for small areas only. One of the most important characteristics of a map projection is whether it is “equal area” (the scale of the map is constant) or “conformal” (the shapes of the geographic features are as they are seen on a globe). No two dimensional map projection can be both conformal and equal-area (but they can be approximately both for smaller areas, e.g. UTM, or Lambert Equal Area for a larger area), and some are neither.\n\n\n6.2.2 Notation\nA planar CRS is defined by a projection, datum, and a set of parameters. The parameters determine things like where the center of the map is. The number of parameters depends on the projection. It is therefore not trivial to document a projection used, and several systems exist. In R we used to depend on the PROJ.4 notation. PROJ.4 is the name of a software library that is commonly used for CRS transformation.\nHere is a list of commonly used projections and their parameters in PROJ4 notation. You can find many more of these on spatialreference.org\nThe PROJ.4 notation is no longer fully supported in the newer versions of the library. It still works for CRSs with the WGS84 datum. For other cases you have to use a EPSG code (if available) or a Well-Known-Text notation.\nMost commonly used CRSs have been assigned a “EPSG code” (EPSG stands for European Petroleum Survey Group). This is a unique ID that can be a simple way to identify a CRS. For example EPSG:27561 is equivalent to +proj=lcc +lat_1=49.5 +lat_0=49.5 +lon_0=0 +k_0=0.999877341 +x_0=6 +y_0=2 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs.\nNow let’s look at an example with a spatial data set in R.\n\np &lt;- vect(\"data/France.shp\")\np\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 13  (geometries, attributes)\n extent      : -5.143751, 9.560416, 41.33375, 51.0894  (xmin, xmax, ymin, ymax)\n source      : France.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :     GID_2 GID_0 COUNTRY   GID_1          NAME_1 NL_NAME_1\n type        :     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;     &lt;chr&gt;\n values      : FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n  NAME_2    VARNAME_2 NL_NAME_2      TYPE_2 (and 3 more)\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n     Ain           NA        NA Département             \n  Allier Basses-Alpes        NA Département             \n Ardèche           NA        NA Département             \n\n\nWe can inspect the coordinate reference system like this.\n\ncrs(p)\n\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#assigning-a-crs",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#assigning-a-crs",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "6.3 Assigning a CRS",
    "text": "6.3 Assigning a CRS\nSometimes we have data without a CRS. This can be because the file used was incomplete, or perhaps because we created the data ourselves with R code. In that case we can assign the CRS if we know what it should be. Here I first remove the CRS of pp and then I set it again.\n\npp &lt;- p\ncrs(pp) &lt;- \"\"\ncrs(pp)\n\n[1] \"\"\n\ncrs(pp) &lt;- \"+proj=longlat +datum=WGS84\"\ncrs(pp)\n\n[1] \"GEOGCRS[\\\"unknown\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ID[\\\"EPSG\\\",6326]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n        ID[\\\"EPSG\\\",8901]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"longitude\\\",east,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433,\\n                ID[\\\"EPSG\\\",9122]]],\\n        AXIS[\\\"latitude\\\",north,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433,\\n                ID[\\\"EPSG\\\",9122]]]]\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou should not use this approach to change the CRS of a data set from what it is to what you want it to be. Assigning a CRS is like labeling something. You need to provide the label that corresponds to the item. Not to what you would like it to be. For example if you label a bicycle, you can write “bicycle”. Perhaps you would prefer a car, and you can label your bicycle as “car” but that would not do you any good. It is still a bicycle. You can try to transform your bicycle into a car. That would not be easy. Transforming spatial data is easier.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#transforming-vector-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#transforming-vector-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "6.4 Transforming vector data",
    "text": "6.4 Transforming vector data\nWe can transform these data to a new data set with another CRS using the project method.\nHere we use the Belgian Lambert 72 projection. First we need to find the correct notation. spatialreference.org\n\np &lt;- vect(\"data/France.shp\")\nnewcrs &lt;- \"EPSG:31370\"\nFrance_Lambert &lt;- terra::project(p, newcrs)\nplot(France_Lambert)\n\n\n\n\n\n\n\np\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 13  (geometries, attributes)\n extent      : -5.143751, 9.560416, 41.33375, 51.0894  (xmin, xmax, ymin, ymax)\n source      : France.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :     GID_2 GID_0 COUNTRY   GID_1          NAME_1 NL_NAME_1\n type        :     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;     &lt;chr&gt;\n values      : FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n  NAME_2    VARNAME_2 NL_NAME_2      TYPE_2 (and 3 more)\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n     Ain           NA        NA Département             \n  Allier Basses-Alpes        NA Département             \n Ardèche           NA        NA Département             \n\nFrance_Lambert\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 13  (geometries, attributes)\n extent      : -552171.5, 582875.6, -877161.8, 199264.6  (xmin, xmax, ymin, ymax)\n coord. ref. : BD72 / Belgian Lambert 72 (EPSG:31370) \n names       :     GID_2 GID_0 COUNTRY   GID_1          NAME_1 NL_NAME_1\n type        :     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;     &lt;chr&gt;\n values      : FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n  NAME_2    VARNAME_2 NL_NAME_2      TYPE_2 (and 3 more)\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n     Ain           NA        NA Département             \n  Allier Basses-Alpes        NA Département             \n Ardèche           NA        NA Département             \n\n\nAfter the transformation, the units of the geometry are no longer in degrees, but in meters away from (longitude=0, latitude=0). The spatial extent of the data is also in these units.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#transforming-raster-data",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#transforming-raster-data",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "6.4 Transforming raster data",
    "text": "6.4 Transforming raster data\nVector data can be transformed from lon/lat coordinates to planar and back without loss of precision. This is not the case with raster data. A raster consists of rectangular cells of the same size (in terms of the units of the CRS; their actual size may vary). It is not possible to transform cell by cell. For each new cell, values need to be estimated based on the values in the overlapping old cells. If the values are categorical data, the “nearest neighbor” method is commonly used. Otherwise some sort of interpolation is employed (e.g. “bilinear”).\nBecause projection of rasters affects the cell values, in most cases you will want to avoid projecting raster data and rather project vector data. But here is how you can project raster data.\n\nLushi &lt;- rast(\"data/Lubumbashi_Sentinel2b.tif\")\nnewcrs &lt;- \"EPSG:31370\"\nLushi_Lambert &lt;- terra::project(Lushi, newcrs)\nplot(Lushi_Lambert)\n\n\n\n\n\n\n\n\nBut that is not a good method. As you should want to assure that you project to exactly the raster parameters you need (so that it lines up with other raster data you are using).\nTo have this kind of control, provide an existing SpatRaster with the geometry (ie extent and resolution) you desire. Check out ?project for all the options. That is generally the best way to project raster. By providing an existing SpatRaster, such that your newly projected data perfectly aligns with it.\n\npr3 &lt;- terra::project(Lushi, Lushi_Lambert)\n\nFor raster based analysis it is often important to use equal area projections, particularly when large areas are analyzed. This will assure that the grid cells are all of same size, and therefore comparable to each other, especially when count data are used.",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-data-from-the-geodata-package",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-data-from-the-geodata-package",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "7.1 Vector data from the geodata package",
    "text": "7.1 Vector data from the geodata package\ngeodata is an R package for downloading geographic data. This package facilitates access to climate, elevation, soil, crop, species occurrence, and administrative boundary data, and is a successor of the getData() function from the raster package. You can find a very detailed description of the data that is available here. Explore this!\nYou can install the released version of geodata in your R environment from CRAN\n\ninstall.packages(\"geodata\")\n\nType ?geodata to see the help for this function. We can now easily access data from different online sources such as the Global Administrative Area Data base. Before we start, let’s have a look at the settings for the geodata package. When you request data, you can download it locally on your computer. It makes sense to assign a fixed folder so you only have to download the data once. You can do these using the following code. With the geodata_path()function you can request the path. Cool!\n\nlibrary(geodata)\noptions(geodata_default_path = \"data\")\ngeodata_path()\n\n[1] \"data\"\n\n\nNow download France from the GADM database. Have a look at the options for this function by typing ?gadm\n\nadm &lt;- gadm(country = \"FRA\", level = 2, download = TRUE)\nplot(adm)\n\n\n\n\n\n\n\n\nNote that you can use datasets which are available locally as they are stored as *.rdsfiles. The file is saved as and .RDS file: this file stores the R* data object in its own binary format. (note that you have to point to your geodata_path(), subfolder that represents the dataset (in this case GADM) and the filename.\n\nfilename &lt;- file.path(geodata_path(), \"/gadm/gadm41_FRA_2_pk.rds\")\nFrance_SpatV &lt;- vect(filename)\n\nExplore the object using the following functions:\n\nclass(France_SpatV)\nnames(France_SpatV)\nsummary(France_SpatV)\nhead(France_SpatV)\nFrance_SpatV$NAME_1\nFrance_SpatV\n\nWe can now explore the different component of the data object using the “$” characters\n\nhead(France_SpatV$GID_2)\n\n[1] \"FRA.1.1_1\" \"FRA.1.2_1\" \"FRA.1.3_1\" \"FRA.1.4_1\" \"FRA.1.5_1\" \"FRA.1.6_1\"\n\nFrance_SpatV$NAME_1\n\n [1] \"Auvergne-Rhône-Alpes\"       \"Auvergne-Rhône-Alpes\"      \n [3] \"Auvergne-Rhône-Alpes\"       \"Auvergne-Rhône-Alpes\"      \n [5] \"Auvergne-Rhône-Alpes\"       \"Auvergne-Rhône-Alpes\"      \n [7] \"Auvergne-Rhône-Alpes\"       \"Auvergne-Rhône-Alpes\"      \n [9] \"Auvergne-Rhône-Alpes\"       \"Auvergne-Rhône-Alpes\"      \n[11] \"Auvergne-Rhône-Alpes\"       \"Auvergne-Rhône-Alpes\"      \n[13] \"Bourgogne-Franche-Comté\"    \"Bourgogne-Franche-Comté\"   \n[15] \"Bourgogne-Franche-Comté\"    \"Bourgogne-Franche-Comté\"   \n[17] \"Bourgogne-Franche-Comté\"    \"Bourgogne-Franche-Comté\"   \n[19] \"Bourgogne-Franche-Comté\"    \"Bourgogne-Franche-Comté\"   \n[21] \"Bretagne\"                   \"Bretagne\"                  \n[23] \"Bretagne\"                   \"Bretagne\"                  \n[25] \"Centre-Val de Loire\"        \"Centre-Val de Loire\"       \n[27] \"Centre-Val de Loire\"        \"Centre-Val de Loire\"       \n[29] \"Centre-Val de Loire\"        \"Centre-Val de Loire\"       \n[31] \"Corse\"                      \"Corse\"                     \n[33] \"Grand Est\"                  \"Grand Est\"                 \n[35] \"Grand Est\"                  \"Grand Est\"                 \n[37] \"Grand Est\"                  \"Grand Est\"                 \n[39] \"Grand Est\"                  \"Grand Est\"                 \n[41] \"Grand Est\"                  \"Grand Est\"                 \n[43] \"Hauts-de-France\"            \"Hauts-de-France\"           \n[45] \"Hauts-de-France\"            \"Hauts-de-France\"           \n[47] \"Hauts-de-France\"            \"Île-de-France\"             \n[49] \"Île-de-France\"              \"Île-de-France\"             \n[51] \"Île-de-France\"              \"Île-de-France\"             \n[53] \"Île-de-France\"              \"Île-de-France\"             \n[55] \"Île-de-France\"              \"Normandie\"                 \n[57] \"Normandie\"                  \"Normandie\"                 \n[59] \"Normandie\"                  \"Normandie\"                 \n[61] \"Nouvelle-Aquitaine\"         \"Nouvelle-Aquitaine\"        \n[63] \"Nouvelle-Aquitaine\"         \"Nouvelle-Aquitaine\"        \n[65] \"Nouvelle-Aquitaine\"         \"Nouvelle-Aquitaine\"        \n[67] \"Nouvelle-Aquitaine\"         \"Nouvelle-Aquitaine\"        \n[69] \"Nouvelle-Aquitaine\"         \"Nouvelle-Aquitaine\"        \n[71] \"Nouvelle-Aquitaine\"         \"Nouvelle-Aquitaine\"        \n[73] \"Occitanie\"                  \"Occitanie\"                 \n[75] \"Occitanie\"                  \"Occitanie\"                 \n[77] \"Occitanie\"                  \"Occitanie\"                 \n[79] \"Occitanie\"                  \"Occitanie\"                 \n[81] \"Occitanie\"                  \"Occitanie\"                 \n[83] \"Occitanie\"                  \"Occitanie\"                 \n[85] \"Occitanie\"                  \"Pays de la Loire\"          \n[87] \"Pays de la Loire\"           \"Pays de la Loire\"          \n[89] \"Pays de la Loire\"           \"Pays de la Loire\"          \n[91] \"Provence-Alpes-Côte d'Azur\" \"Provence-Alpes-Côte d'Azur\"\n[93] \"Provence-Alpes-Côte d'Azur\" \"Provence-Alpes-Côte d'Azur\"\n[95] \"Provence-Alpes-Côte d'Azur\" \"Provence-Alpes-Côte d'Azur\"\n\n\nWe can also investigate the characteristics of spatial vector using the following functions\n\ncrs(France_SpatV, proj = T)\n\n[1] \"+proj=longlat +datum=WGS84 +no_defs\"\n\next(France_SpatV)\n\nSpatExtent : -5.1437509999999, 9.56041622200013, 41.3337520000001, 51.0893974320001 (xmin, xmax, ymin, ymax)\n\n\nand subset…\n\nfraL2_s &lt;- France_SpatV[which(France_SpatV$GID_1 == \"FRA.1_1\"), ] # subset the spatial object\nplot(fraL2_s)\n\n\n\n\n\n\n\nplot(France_SpatV)\nplot(fraL2_s, col = \"red\", add = T)\n\n\n\n\n\n\n\n\nother ways to subset\n\nfraL2_s2 &lt;- subset(France_SpatV, France_SpatV$GID_1 == \"FRA.1_1\") # subset the spatial object\n\ndf &lt;- as.data.frame(France_SpatV[which(France_SpatV$GID_1 == \"FRA.1_1\"), ]) # subset only the data.frame of the spatial object",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#leaflet",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#leaflet",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "7.2 Leaflet",
    "text": "7.2 Leaflet\nLeaflet is one of the most popular open-source JavaScript libraries for interactive maps. It is used by websites ranging from The New York Times and The Washington Post as well as GIS specialists like OpenStreetMap, Mapbox and CartoDB. There is an R package that makes it easy to integrate and control leaflet maps in R. Here we show some basic examples. More information can be found here.\nFirst, you need to install the leaflet package and direct R to use the library:\n\ninstall.packages(\"leaflet\")\n\n\nlibrary(leaflet)\nm &lt;- leaflet()\nm &lt;- addTiles(m)\nm &lt;- addMarkers(m, lng = 4.62080, lat = 50.66607, popup = \"UCL Geo, I'm here with you right now ;)\")\n\nm is a leaflet htmlwidget (use class(m) to verify this). You can now visualize this with:\n\nm\n\n\n\n\n\nYou can now easily overlay vector files. Note that we can use the R ‘pipes’ (%\\&gt;%) to simplify this code: the shortcut for the pipe operator is ctrl+shift+M.Be carefull here, the function does not know how to access to the spatial vector. Tips: you can transform the spatial vector in a sf (simple features) with st_as_sf function from the sf package.\n\nm2 &lt;- leaflet() %&gt;%\n    addTiles() %&gt;%\n    addPolygons(data = France_SpatV)\nm2\n\n\n\n\n\n\ncities &lt;- read.csv(\"data/cities_FRA.csv\")\ncities &lt;- vect(cities, geom = c(\"long\", \"lat\"))\ncrs(cities) &lt;- \"+proj=longlat +datum=WGS84\"\n\nAdd Polygons subset and cities\n\nm2 &lt;- leaflet() %&gt;%\n    addTiles() %&gt;%\n    addPolygons(data = France_SpatV) %&gt;%\n    addPolygons(data = fraL2_s, fillOpacity = 1, color = \"red\") %&gt;%\n    addCircleMarkers(data = cities, popup = ~ as.character(city), label = ~ as.character(city), radius = ~ (exp(pop) / 100), color = \"green\", fillOpacity = 1)\nm2\n\n\n\n\n\nYou can read more about this here\nNote that this map is shown in the Viewer and can be saved as an html page using the Export function.\n\n7.2.1 Third-Party Tiles\nAlternatively, many popular free third-party basemaps can be added using the addProviderTiles() function, which is implemented using the leaflet-providers plugin. See here for the complete set. Note that some tile set providers require you to register; see the project page for more information.\n\naddProviderTiles(map = m, provider = \"OpenTopoMap\")\n\n\n\n\n\n\n\n7.2.2 WMS Tiles\nYou can use addWMSTiles() to add WMS (Web Map Service) tiles.\n\nm &lt;- leaflet() %&gt;%\n    addTiles(\"http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n        attribution = \"Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid,IGN, IGP, UPR-EGP, and the GIS User Community\"\n    )\nm\n\n\n\n\n\nThere we go. Note that this code pulls in a tile set, and allows you to set attributions for the tiles in the bottom right. Always be sure to include attribution for whoever made the map tiles!\nThis code also assigns the leaflet map to “m”. We can now use the pipe operator to put different layers on this basic map. This is useful if you want to manage several different map backgrounds, or a single default map that you want to show with different data layers.\nThough the map has a zoom button built in, you can also set the initial starting map center and zoom level explicitly.\n\nm %&gt;%\n    setView(4.62080, 50.66607, zoom = 16)\n\n\n\n\n\nYou can also built your own tiles from a raster map. Here is an example of a tillage erosion map from Kristof’s website. It is possible to create your own tiles (eg Tilemill application)…\n\nleaflet() %&gt;%\n    setView(4.62080, 50.66607, zoom = 6) %&gt;%\n    addTiles(\n        urlTemplate = \"http://www.climate.be/users/vanoost/Maps/TilMapV500/{z}/{x}/{y}.png\",\n        attribution = \"Data source: KVO\", options = tileOptions(minZoom = 3, maxZoom = 13, tms = TRUE)\n    ) %&gt;%\n    addPolygons(data = France_SpatV, col = \"black\", weight = 2, smoothFactor = 0.3)\n\n\n\n\n\nNote the url to Kristof’s website and the formatting options at the end the command.\n\n\n7.2.3 Lets plot some data\nGet Earthquake data from the USGS server (check out the website for more information):\n\nm3 &lt;- leaflet()\nEQ &lt;- read.csv(\"http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv\", header = TRUE)\nm3 %&gt;%\n    addCircles(data = EQ, color = \"red\")\n\n\n\n\n\nYou can now easily adjust this:\n\nm %&gt;%\n    addTiles() %&gt;%\n    addCircleMarkers(\n        data = EQ,\n        radius = ~ exp(mag) / 100, color = \"red\"\n    )\n\n\n\n\n\nor a bit more sophisticated\n\nm %&gt;%\n    addTiles() %&gt;%\n    addMarkers(data = subset(EQ, mag &gt; 6), ~longitude, ~latitude, popup = ~ as.character(mag))\n\n\n\n\n\nNote the use of the subset() function to select Earthquakes with a magnitude larger than 6. Easy!",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#rastervis",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#rastervis",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "7.3 rasterVIS",
    "text": "7.3 rasterVIS\nThe rasterVis package complements the terra package. Install this package: install.packages(\"rasterVis\") and call the library\n\ntmin1 &lt;- rast(\"data/tmin1crop.tif\")\nlibrary(geodata)\ntmin &lt;- geodata::worldclim_global(var = \"tmin\", res = 10)\nlibrary(rasterVis)\n\nDifferent plotting functions:\n\nhistogram(tmin1)\n\n\n\n\n\n\n\n\n\npersp(tmin1)\n\n\n\n\n\n\n\n\n\nplot(tmin1)\n\n\n\n\n\n\n\ncontourplot(tmin1, add = TRUE) # you can add a contourplot by setting the add option to TRUE\n\n\n\n\n\n\n\n\n\nlevelplot(tmin1)\n\n\n\n\n\n\n\n\n\nbwplot(tmin)\n\n\n\n\n\n\n\npairs(tmin)\n\n\n\n\n\n\n\n\n\ndensityplot(tmin1)",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-with-terra",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-with-terra",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "8.1 Vector (with terra)",
    "text": "8.1 Vector (with terra)\nThis section illustrates some ways in which we can manipulate vector data. We start with an example SpatVector that we read from a shapefile.\n\nlibrary(terra)\np &lt;- vect(\"data/France.shp\")\np\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 13  (geometries, attributes)\n extent      : -5.143751, 9.560416, 41.33375, 51.0894  (xmin, xmax, ymin, ymax)\n source      : France.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :     GID_2 GID_0 COUNTRY   GID_1          NAME_1 NL_NAME_1\n type        :     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;     &lt;chr&gt;\n values      : FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n               FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA\n  NAME_2    VARNAME_2 NL_NAME_2      TYPE_2 (and 3 more)\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n     Ain           NA        NA Département             \n  Allier Basses-Alpes        NA Département             \n Ardèche           NA        NA Département             \n\n\nWe can plot these data in many ways. For example:\n\nplot(p, \"NAME_2\")\n\n\n\n\n\n\n\n\n\n8.1.1 Geometry and attributes\nTo extract the attributes (data.frame) from a SpatVector, use:\n\nd &lt;- as.data.frame(p)\nhead(d)\n\n      GID_2 GID_0 COUNTRY   GID_1               NAME_1 NL_NAME_1      NAME_2\n1 FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;         Ain\n2 FRA.1.2_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;      Allier\n3 FRA.1.3_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;     Ardèche\n4 FRA.1.4_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;      Cantal\n5 FRA.1.5_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt;       Drôme\n6 FRA.1.6_1   FRA  France FRA.1_1 Auvergne-Rhône-Alpes      &lt;NA&gt; Haute-Loire\n     VARNAME_2 NL_NAME_2      TYPE_2  ENGTYPE_2 CC_2 HASC_2\n1         &lt;NA&gt;      &lt;NA&gt; Département Department   01  FR.AI\n2 Basses-Alpes      &lt;NA&gt; Département Department   03  FR.AL\n3         &lt;NA&gt;      &lt;NA&gt; Département Department   07  FR.AH\n4         &lt;NA&gt;      &lt;NA&gt; Département Department   15  FR.CL\n5         &lt;NA&gt;      &lt;NA&gt; Département Department   26  FR.DM\n6         &lt;NA&gt;      &lt;NA&gt; Département Department   43  FR.HL\n\n\n\n\n8.1.2 Variables\nYou can extract a variable as you would do with a data.frame.\n\np$NAME_2\n\n [1] \"Ain\"                     \"Allier\"                 \n [3] \"Ardèche\"                 \"Cantal\"                 \n [5] \"Drôme\"                   \"Haute-Loire\"            \n [7] \"Haute-Savoie\"            \"Isère\"                  \n [9] \"Loire\"                   \"Puy-de-Dôme\"            \n[11] \"Rhône\"                   \"Savoie\"                 \n[13] \"Côte-d'Or\"               \"Doubs\"                  \n[15] \"Haute-Saône\"             \"Jura\"                   \n[17] \"Nièvre\"                  \"Saône-et-Loire\"         \n[19] \"Territoire de Belfort\"   \"Yonne\"                  \n[21] \"Côtes-d'Armor\"           \"Finistère\"              \n[23] \"Ille-et-Vilaine\"         \"Morbihan\"               \n[25] \"Cher\"                    \"Eure-et-Loir\"           \n[27] \"Indre\"                   \"Indre-et-Loire\"         \n[29] \"Loir-et-Cher\"            \"Loiret\"                 \n[31] \"Corse-du-Sud\"            \"Haute-Corse\"            \n[33] \"Ardennes\"                \"Aube\"                   \n[35] \"Bas-Rhin\"                \"Haut-Rhin\"              \n[37] \"Haute-Marne\"             \"Marne\"                  \n[39] \"Meurthe-et-Moselle\"      \"Meuse\"                  \n[41] \"Moselle\"                 \"Vosges\"                 \n[43] \"Aisne\"                   \"Nord\"                   \n[45] \"Oise\"                    \"Pas-de-Calais\"          \n[47] \"Somme\"                   \"Essonne\"                \n[49] \"Hauts-de-Seine\"          \"Paris\"                  \n[51] \"Seine-et-Marne\"          \"Seine-Saint-Denis\"      \n[53] \"Val-d'Oise\"              \"Val-de-Marne\"           \n[55] \"Yvelines\"                \"Calvados\"               \n[57] \"Eure\"                    \"Manche\"                 \n[59] \"Orne\"                    \"Seine-Maritime\"         \n[61] \"Charente\"                \"Charente-Maritime\"      \n[63] \"Corrèze\"                 \"Creuse\"                 \n[65] \"Deux-Sèvres\"             \"Dordogne\"               \n[67] \"Gironde\"                 \"Haute-Vienne\"           \n[69] \"Landes\"                  \"Lot-et-Garonne\"         \n[71] \"Pyrénées-Atlantiques\"    \"Vienne\"                 \n[73] \"Ariège\"                  \"Aude\"                   \n[75] \"Aveyron\"                 \"Gard\"                   \n[77] \"Gers\"                    \"Haute-Garonne\"          \n[79] \"Hautes-Pyrénées\"         \"Hérault\"                \n[81] \"Lot\"                     \"Lozère\"                 \n[83] \"Pyrénées-Orientales\"     \"Tarn\"                   \n[85] \"Tarn-et-Garonne\"         \"Loire-Atlantique\"       \n[87] \"Maine-et-Loire\"          \"Mayenne\"                \n[89] \"Sarthe\"                  \"Vendée\"                 \n[91] \"Alpes-de-Haute-Provence\" \"Alpes-Maritimes\"        \n[93] \"Bouches-du-Rhône\"        \"Hautes-Alpes\"           \n[95] \"Var\"                     \"Vaucluse\"               \n\n\nTo subset a SpatVector to one or more variables you can use the notation below. Note how this is different from the above example. Above a vector of values is returned. With the approach below you get a new SpatVector with only one variable.\n\np[, \"NAME_2\"]\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 1  (geometries, attributes)\n extent      : -5.143751, 9.560416, 41.33375, 51.0894  (xmin, xmax, ymin, ymax)\n source      : France.shp\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :  NAME_2\n type        :   &lt;chr&gt;\n values      :     Ain\n                Allier\n               Ardèche\n\n\n\n\n8.1.3 Merge\nYou can assign an attributes table (data.frame) to a SpatVector with values&lt;-. To add attributes to a SpatVector that already has attributes use merge (or cbind if you know the order of the records is the same).\n\ndfr &lt;- data.frame(District = p$NAME_1, Canton = p$NAME_2, Value = round(runif(length(p), 100, 1000)))\ndfr &lt;- dfr[order(dfr$Canton), ]\npm &lt;- merge(p, dfr, by.x = c(\"NAME_1\", \"NAME_2\"), by.y = c(\"District\", \"Canton\"))\npm\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 96, 14  (geometries, attributes)\n extent      : -5.143751, 9.560416, 41.33375, 51.0894  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :          NAME_1  NAME_2     GID_2 GID_0 COUNTRY   GID_1\n type        :           &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;\n values      : Auvergne-Rhône~     Ain FRA.1.1_1   FRA  France FRA.1_1\n               Auvergne-Rhône~  Allier FRA.1.2_1   FRA  France FRA.1_1\n               Auvergne-Rhône~ Ardèche FRA.1.3_1   FRA  France FRA.1_1\n NL_NAME_1    VARNAME_2 NL_NAME_2      TYPE_2 (and 4 more)\n     &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n        NA           NA        NA Département             \n        NA Basses-Alpes        NA Département             \n        NA           NA        NA Département             \n\n\nSelecting rows (records)\n\ni &lt;- which(p$NAME_2 == \"Ain\")\ng &lt;- p[i, ]\ng\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 1, 13  (geometries, attributes)\n extent      : 4.730582, 6.168451, 45.61149, 46.51768  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :     GID_2 GID_0 COUNTRY   GID_1          NAME_1 NL_NAME_1 NAME_2\n type        :     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;\n values      : FRA.1.1_1   FRA  France FRA.1_1 Auvergne-Rhône~        NA    Ain\n VARNAME_2 NL_NAME_2      TYPE_2 (and 3 more)\n     &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \n        NA        NA Département",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-with-sf",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#vector-with-sf",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "8.2 Vector (with sf)",
    "text": "8.2 Vector (with sf)\nAs explained earlier, sf can integrate seamlessly with the tidyverse by treating spatial objects as tibbles with an additional geometry column. This makes operations intuitive and consistent with other tidyverse functions (e.g., easily plot spatial data with ggplot2).\nThe st_read() function loads the shapefile and returns it as an sf object. Let’s inspect the object:\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Read the shapefile\nfrance_sf &lt;- st_read(\"data/France.shp\")\n\nReading layer `France' from data source \n  `/Users/Antoine_Stevens/Library/CloudStorage/OneDrive-McKinsey&Company/Documents/Projects/LGEO/Intro to Spatial Data/data/France.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 96 features and 13 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -5.143751 ymin: 41.33375 xmax: 9.560416 ymax: 51.0894\nGeodetic CRS:  WGS 84\n\n# Inspect the `sf` object\nglimpse(france_sf)\n\nRows: 96\nColumns: 14\n$ GID_2     &lt;chr&gt; \"FRA.1.1_1\", \"FRA.1.2_1\", \"FRA.1.3_1\", \"FRA.1.4_1\", \"FRA.1.5…\n$ GID_0     &lt;chr&gt; \"FRA\", \"FRA\", \"FRA\", \"FRA\", \"FRA\", \"FRA\", \"FRA\", \"FRA\", \"FRA…\n$ COUNTRY   &lt;chr&gt; \"France\", \"France\", \"France\", \"France\", \"France\", \"France\", …\n$ GID_1     &lt;chr&gt; \"FRA.1_1\", \"FRA.1_1\", \"FRA.1_1\", \"FRA.1_1\", \"FRA.1_1\", \"FRA.…\n$ NAME_1    &lt;chr&gt; \"Auvergne-Rhône-Alpes\", \"Auvergne-Rhône-Alpes\", \"Auvergne-Rh…\n$ NL_NAME_1 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ NAME_2    &lt;chr&gt; \"Ain\", \"Allier\", \"Ardèche\", \"Cantal\", \"Drôme\", \"Haute-Loire\"…\n$ VARNAME_2 &lt;chr&gt; NA, \"Basses-Alpes\", NA, NA, NA, NA, NA, NA, NA, NA, NA, \"Sab…\n$ NL_NAME_2 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ TYPE_2    &lt;chr&gt; \"Département\", \"Département\", \"Département\", \"Département\", …\n$ ENGTYPE_2 &lt;chr&gt; \"Department\", \"Department\", \"Department\", \"Department\", \"Dep…\n$ CC_2      &lt;chr&gt; \"01\", \"03\", \"07\", \"15\", \"26\", \"43\", \"74\", \"38\", \"42\", \"63\", …\n$ HASC_2    &lt;chr&gt; \"FR.AI\", \"FR.AL\", \"FR.AH\", \"FR.CL\", \"FR.DM\", \"FR.HL\", \"FR.HS…\n$ geometry  &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((5.623748 45..., MULTIPOLYGON ((…\n\n\nNotice how the geometry column stores spatial data while other columns contain attribute information.\n\n8.2.1 Basic Operations\nSince sf integrates with the tidyverse, we can use familiar functions like filter(), mutate(), and select().\nLet’s join some population data and filter regions ….\n\n# add population density\npopulation_density &lt;- data.frame(\n    NAME_1 = c(\n        \"Île-de-France\", \"Hauts-de-France\", \"Provence-Alpes-Côte d'Azur\", \"Bretagne\",\n        \"Pays de la Loire\", \"Auvergne-Rhône-Alpes\", \"Normandie\", \"Grand Est\",\n        \"Occitanie\", \"Nouvelle-Aquitaine\", \"Centre-Val de Loire\", \"Bourgogne-Franche-Comté\", \"Corse\"\n    ),\n    population_density = c(1027, 189, 161, 120, 119, 113, 109, 97, 87, 72, 64, 59, 40),\n    geographic_location = c(\n        \"North\", \"North\", \"South\", \"West\",\n        \"West\", \"East\", \"West\", \"East\",\n        \"South\", \"West\", \"West\", \"East\", \"South\"\n    )\n)\n\nfrance_sf &lt;- france_sf %&gt;%\n    left_join(population_density)\n\n# Filter\nfrance_sf_filtered &lt;- france_sf %&gt;%\n    filter(population_density &lt;= 100)\n\n# Preview the result\nhead(france_sf_filtered)\n\nSimple feature collection with 6 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.845187 ymin: 46.15681 xmax: 7.060264 ymax: 48.03138\nGeodetic CRS:  WGS 84\n      GID_2 GID_0 COUNTRY   GID_1                  NAME_1 NL_NAME_1\n1 FRA.2.1_1   FRA  France FRA.2_1 Bourgogne-Franche-Comté      &lt;NA&gt;\n2 FRA.2.2_1   FRA  France FRA.2_1 Bourgogne-Franche-Comté      &lt;NA&gt;\n3 FRA.2.3_1   FRA  France FRA.2_1 Bourgogne-Franche-Comté      &lt;NA&gt;\n4 FRA.2.4_1   FRA  France FRA.2_1 Bourgogne-Franche-Comté      &lt;NA&gt;\n5 FRA.2.5_1   FRA  France FRA.2_1 Bourgogne-Franche-Comté      &lt;NA&gt;\n6 FRA.2.6_1   FRA  France FRA.2_1 Bourgogne-Franche-Comté      &lt;NA&gt;\n          NAME_2 VARNAME_2 NL_NAME_2      TYPE_2  ENGTYPE_2 CC_2 HASC_2\n1      Côte-d'Or      &lt;NA&gt;      &lt;NA&gt; Département Department   21  FR.CO\n2          Doubs      &lt;NA&gt;      &lt;NA&gt; Département Department   25  FR.DB\n3    Haute-Saône      &lt;NA&gt;      &lt;NA&gt; Département Department   70  FR.HN\n4           Jura      &lt;NA&gt;      &lt;NA&gt; Département Department   39  FR.JU\n5         Nièvre      &lt;NA&gt;      &lt;NA&gt; Département Department   58  FR.NI\n6 Saône-et-Loire      &lt;NA&gt;      &lt;NA&gt; Département Department   71  FR.SL\n  population_density geographic_location                       geometry\n1                 59                East MULTIPOLYGON (((5.057017 46...\n2                 59                East MULTIPOLYGON (((6.180198 46...\n3                 59                East MULTIPOLYGON (((5.691668 47...\n4                 59                East MULTIPOLYGON (((5.764418 47...\n5                 59                East MULTIPOLYGON (((3.259773 46...\n6                 59                East MULTIPOLYGON (((4.027488 46...\n\n\nPlotting spatial data with ggplot2 is simple too. The geometry column is automatically recognized.\n\n# Plot the regions with population density\nggplot(france_sf) +\n    geom_sf(aes(fill = population_density)) +\n    scale_fill_viridis_c() +\n    theme_minimal() +\n    labs(\n        title = \"Population Density in France\",\n        fill = \"Density (people per unit area)\"\n    )\n\n\n\n\n\n\n\n\n\n\n8.2.2 Spatial Operations\nsf allows spatial operations like intersections, unions, and transformations. See below for an exhaustive list of functions\n\n\n\n\n\n\n\nSource: (&lt;https://rstudio.github.io/cheatsheets/sf.pdf&gt;)[https://rstudio.github.io/cheatsheets/sf.pdf]\n\n\n\n\n\n\n\n\n\nSource: (://rstudio.github.io/cheatsheets/sf.pdf&gt;)[https://rstudio.github.io/cheatsheets/sf.pdf]\n\n\n\n\n8.2.3 Be Careful with summarizing functions on sf objects…\nWhen working with sf objects, summarizing functions can unintentionally create unions of geometries. This is because the geometry column, which stores spatial data, is treated as part of the dataset and will be summarized too. While this behavior can be desirable for some use cases, it may not always be what we want.\n\nExample: Summarizing without dropping geometry\nLet’s calculate the average population density by region type (without weighting by ara). Here’s what happens if we summarize without handling the geometry column explicitly:\n\nlibrary(tictoc)\n# Summarizing without dropping geometry\ntictoc::tic() # to check computation time\nregion_summary &lt;- france_sf %&gt;%\n    group_by(geographic_location) %&gt;%\n    summarize(\n        population_density = mean(population_density, na.rm = TRUE)\n    )\ntictoc::toc()\n\n2.954 sec elapsed\n\n# Inspect the result\nprint(region_summary)\n\nSimple feature collection with 4 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: -5.143751 ymin: 41.33375 xmax: 9.560416 ymax: 51.0894\nGeodetic CRS:  WGS 84\n# A tibble: 4 × 3\n  geographic_location population_density                                geometry\n  &lt;chr&gt;                            &lt;dbl&gt;                          &lt;GEOMETRY [°]&gt;\n1 East                              93.3 POLYGON ((7.206223 47.43489, 7.223328 …\n2 North                            705.  MULTIPOLYGON (((1.704364 49.2322, 1.69…\n3 South                            104.  MULTIPOLYGON (((4.889463 44.30402, 4.9…\n4 West                              89.6 MULTIPOLYGON (((0.132639 49.66403, 0.1…\n\n\nNote how it returns just four rows corresponing to the fourgeographic_locations. In this case, the geometry column is aggregated by creating unions of geometries for each group, which can be computationally intensive and not always necessary. Note that we could use other operators than st_union() like st_combine(): it combines geometries into a single geometry collection without dissolving boundaries or ensuring topological validity. This is faster and ideal for non-spatial aggregations where the geometry is still needed. We would do:\n\ntictoc::tic()\n# Summarize with st_combine\nregion_summary_combine &lt;- france_sf %&gt;%\n    group_by(geographic_location) %&gt;%\n    summarize(\n        population_density = mean(population_density, na.rm = TRUE),\n        geometry = st_combine(geometry) # Use st_combine instead of default st_union\n    )\ntictoc::toc()\n\n0.017 sec elapsed\n\n# Much faster!\n# Inspect the result\nprint(region_summary_combine)\n\nSimple feature collection with 4 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -5.143751 ymin: 41.33375 xmax: 9.560416 ymax: 51.0894\nGeodetic CRS:  WGS 84\n# A tibble: 4 × 3\n  geographic_location population_density                                geometry\n  &lt;chr&gt;                            &lt;dbl&gt;                      &lt;MULTIPOLYGON [°]&gt;\n1 East                              93.3 (((5.623748 45.61327, 5.614911 45.6254…\n2 North                            705.  (((3.398898 48.86642, 3.405856 48.8758…\n3 South                            104.  (((9.259028 41.34792, 9.259028 41.3476…\n4 West                              89.6 (((-2.668668 48.04678, -2.667 48.0567,…\n\n\n\n\nAvoiding geometry unions with st_drop_geometry\nIf we want to summarize the data without creating geometry unions, we need to drop the geometry column before applying the summarizing functions. This can be done using st_drop_geometry(). This approach is computationally efficient and avoids unintended spatial operations.\n\n# Drop geometry before summarizing\nregion_summary_no_geom &lt;- france_sf %&gt;%\n    st_drop_geometry() %&gt;%\n    group_by(geographic_location) %&gt;%\n    summarize(\n        population_density = mean(population_density, na.rm = TRUE)\n    )\n\n# Inspect the result\nprint(region_summary_no_geom)\n\n# A tibble: 4 × 2\n  geographic_location population_density\n  &lt;chr&gt;                            &lt;dbl&gt;\n1 East                              93.3\n2 North                            705. \n3 South                            104. \n4 West                              89.6",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#raster",
    "href": "Intro to Spatial Data/LGEO2185_Intro_to_Spatial_Data.html#raster",
    "title": "LGEO2185: Introduction to Spatial Data Manipulation with R",
    "section": "8.3 Raster",
    "text": "8.3 Raster\nWe use the geodata function to download some climate date (type ?geodata for help and try to understand the structure and content of the data they provide)\n\ntmin &lt;- geodata::worldclim_global(var = \"tmin\", res = 10)\n\nThis is a Raster with 12 layers, representing a value for each month of the year. Check out how the download created a folder in your current geodata path Plot the raster using plot(tmin) You can load a single layer into a raster object:\n\ntmin1 &lt;- rast(file.path(geodata_path(), \"climate/wc2.1_10m/wc2.1_10m_tmin_01.tif\")) # Tmin for January\nplot(tmin1 / 10) # why dividing by 10? ?worldclim\n\n\n\n\n\n\n\n\nEasy! The raster function reads many different formats, including Arc ASCII grids or netcdf files (see terra help).\n\n8.3.1 Cropping rasters\nThere are many ways to crop rasters, you can provide coordinates for the limits of the region of interest (see example), or you can provide another SpatVector or SpatRaster as argument.\n\nnewext &lt;- ext(-10, 5, 30, 40)\ntmin1.c &lt;- crop(tmin1, newext)\nplot(tmin1.c)\n\n\n\n\n\n\n\n# or\ntmin1.c.copy &lt;- crop(tmin1, tmin1.c)\n\n\n\n8.3.2 Algebra\nMany generic functions that allow for simple and elegant raster algebra have been implemented for Raster objects, including the normal algebraic operators such as +, -, *, /, logical operators such as &gt;, &gt;=, &lt;, ==, ! and functions like abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all. In these functions you can mix raster objects with numbers, as long as the first argument is a raster object. Plot r and s when you apply the algebra!\n\nr &lt;- rast(\"data/chm_lidar.tif\")\ns &lt;- r + 10\ns &lt;- sqrt(s)\ns &lt;- s * r + 5\nvalues(r) &lt;- runif(ncell(r)) # check ?runif, just random numbers\nr &lt;- round(r)\nr &lt;- r == 0 # becomes True of False\ns[r] &lt;- -0.5\ns[!r] &lt;- 5\ns[s == 5] &lt;- 15\n\nSummary functions (min, max, mean, prod, sum, median, cv, range, any, all) always return a SpatRaster object. Perhaps this is not obvious when using functions like min, sum or mean.\n\na &lt;- mean(r, s, 10)\nb &lt;- sum(r, s)\nst &lt;- c(r, s, a, b)\nsst &lt;- sum(st)\nsst\n\nclass       : SpatRaster \nsize        : 1420, 1740, 1  (nrow, ncol, nlyr)\nresolution  : 1, 1  (x, y)\nextent      : 220849.4, 222589.4, 89171.31, 90591.31  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 35N (EPSG:32635) \nsource(s)   : memory\nname        :      sum \nmin value   :  4.50000 \nmax value   : 38.33333 \n\n\nUse global if you want a single number summarizing the cell values of each layer.\n\nglobal(st, \"sum\")\n\n                 sum\nchm_lidar    1235196\nchm_lidar.1 17916462\nchm_lidar.2 14619886\nchm_lidar.3 19151658\n\n\n\n\n8.3.3 ‘High-level’ functions\nSeveral ‘high level’ functions have been implemented for SpatRaster objects. ‘High level’ functions refer to functions that you would normally find in a computer program that supports the analysis of raster data. Here we briefly discuss some of these functions. All these functions work for raster datasets that cannot be loaded into memory. See the help files for more detailed descriptions of each function.\nThe high-level functions have some arguments in common. The first argument is typically a SpatRaster ‘x’ or ‘object’. It is followed by one or more arguments specific to the function (either additional SpatRaster objects or other arguments), followed by filename and ... arguments.\nThe default filename is an empty character \"\". If you do not specify a filename, the default action for the function is to return a raster object that only exists in memory. However, if the function deems that the raster object to be created would be too large to hold in memory, it is written to a temporary file instead.\nThe ... argument allows for setting additional arguments that are relevant when writing values to a file: the file format, datatype (e.g. integer or real values), and a to indicate whether existing files should be overwritten.\n\n\n8.3.4 Modifying a SpatRaster object\nThere are several functions that deal with modifying the spatial extent of SpatRaster objects. The crop function lets you take a geographic subset of a larger raster object. You can crop a SpatRaster by providing an extent object or another spatial object from which an extent can be extracted (objects from classes deriving from Raster and from Spatial in the sp package). An easy way to get an extent object is to plot a SpatRaster and then use drawExtent to visually determine the new extent (bounding box) to provide to the crop function.\ntrim crops a SpatRaster by removing the outer rows and columns that only contain NA values. In contrast, extend adds new rows and/or columns with NA values. The purpose of this could be to create a new SpatRaster with the same Extent of another, larger, SpatRaster such that they can be used together in other functions.\nThe merge function lets you merge 2 or more SpatRaster objects into a single new object. The input objects must have the same resolution and origin (such that their cells neatly fit into a single larger raster). If this is not the case you can first adjust one of the SpatRaster objects with aggregate/disagg or resample.\naggregate and disagg allow for changing the resolution (cell size) of a SpatRaster object. In the case of aggregate, you need to specify a function determining what to do with the grouped cell values mean. It is possible to specify different (dis)aggregation factors in the x and y direction. aggregate and disagg are the best functions when adjusting cells size only, with an integer step (e.g. each side 2 times smaller or larger), but in some cases that is not possible.\nFor example, you may need nearly the same cell size, while shifting the cell centers. In those cases, the resample function can be used. It can do either nearest neighbor assignments (for categorical data) or bilinear interpolation (for numerical data). Simple linear shifts of a Raster object can be accomplished with the shift function or with the extent function.\nWith the warp function you can transform values of SpatRaster object to a new object with a different coordinate reference system.\nHere are some simple examples.\nAggregate and disaggregate.\n\nr &lt;- rast()\nvalues(r) &lt;- 1:ncell(r)\nra &lt;- aggregate(r, 20)\nrd &lt;- disagg(ra, 20)\n\nCrop and merge example.\n\nr1 &lt;- crop(r, ext(-50, 0, 0, 30))\nr2 &lt;- crop(r, ext(-10, 50, -20, 10))\nm &lt;- merge(r1, r2, filename = \"data/test.tif\", overwrite = TRUE)\nplot(m)\n\n\n\n\n\n\n\n\nflip lets you flip the data (reverse order) in horizontal or vertical direction – typically to correct for a ‘communication problem’ between different R packages or a misinterpreted file. rotate lets you rotate longitude/latitude rasters that have longitudes from 0 to 360 degrees (often used by climatologists) to the standard -180 to 180 degrees system. With t you can rotate a SpatRaster object 90 degrees.\n\n\n8.3.5 Overlay\napp (short for “apply”) allows you to do a computation for a single SpatRaster object by providing a function, e.g. sum.\nThe lapp (layer-apply) function can be used as an alternative to the raster algebra discussed above.\n\n\n8.3.6 Classify\nYou can use classify to replace ranges of values with single values, or to substitute (replace) single values with other values.\n\nr &lt;- rast(ncol = 3, nrow = 2)\nvalues(r) &lt;- 1:ncell(r)\nvalues(r)\n\n     lyr.1\n[1,]     1\n[2,]     2\n[3,]     3\n[4,]     4\n[5,]     5\n[6,]     6\n\n\nSet all values above 4 to NA\n\ns &lt;- app(r, fun = function(x) {\n    x[x &lt; 4] &lt;- NA\n    return(x)\n})\nas.matrix(s)\n\n     lyr.1\n[1,]    NA\n[2,]    NA\n[3,]    NA\n[4,]     4\n[5,]     5\n[6,]     6\n\n\nDivide the first raster with two times the square root of the second raster and add five.\n\nrs &lt;- c(r, s)\nw &lt;- lapp(rs, fun = function(x, y) {\n    x / (2 * sqrt(y)) + 5\n})\nas.matrix(w)\n\n         lyr1\n[1,]       NA\n[2,]       NA\n[3,]       NA\n[4,] 6.000000\n[5,] 6.118034\n[6,] 6.224745\n\n\nRemove from r all values that are NA in w.\n\nu &lt;- mask(r, w)\nas.matrix(u)\n\n     lyr.1\n[1,]    NA\n[2,]    NA\n[3,]    NA\n[4,]     4\n[5,]     5\n[6,]     6\n\n\nReplace NA values in w with values of r.\n\ncvr &lt;- cover(w, r)\nas.matrix(w)\n\n         lyr1\n[1,]       NA\n[2,]       NA\n[3,]       NA\n[4,] 6.000000\n[5,] 6.118034\n[6,] 6.224745\n\n\nIdentify the cell values in u that are the same as in s.\n\nv &lt;- u == s\nas.matrix(v)\n\n     lyr.1\n[1,]    NA\n[2,]    NA\n[3,]    NA\n[4,]  TRUE\n[5,]  TRUE\n[6,]  TRUE\n\n\nChange value between 0 and 2 to 1, etc.\n\nx &lt;- classify(w, rbind(c(0, 2, 1), c(2, 5, 2), c(4, 10, 3)))\nas.matrix(x)\n\n     lyr1\n[1,]  NaN\n[2,]  NaN\n[3,]  NaN\n[4,]    3\n[5,]    3\n[6,]    3\n\n\nSubstitute 2 with 40 and 3 with 50.\n\ny &lt;- classify(x, cbind(id = c(2, 3), v = c(40, 50)))\nas.matrix(y)\n\n     lyr1\n[1,]  NaN\n[2,]  NaN\n[3,]  NaN\n[4,]   50\n[5,]   50\n[6,]   50\n\n\n\n\n8.3.7 Vector to raster conversion\nThe terra package supports point, line, and polygon to raster conversion with the rasterize function. For vector type data (points, lines, polygons), SpatVector objects are used; but points can also be represented by a two-column matrix (x and y).\nPoint to raster conversion is often done with the purpose to analyze the point data. For example to count the number of distinct species (represented by point observations) that occur in each raster cell. rasterize takes a SpatRaster object to set the spatial extent and resolution, and a function to determine how to summarize the points (or an attribute of each point) by cell.\nPolygon to raster conversion is typically done to create a SpatRaster that can act as a mask, i.e. to set to NA a set of cells of a SpatRaster object, or to summarize values on a raster by zone. For example a country polygon is transferred to a raster that is then used to set all the cells outside that country to NA; whereas polygons representing administrative regions such as states can be transferred to a raster to summarize raster values by region.\nIt is also possible to convert the values of a SpatRaster to points or polygons, using as.points and as.polygons. Both functions only return values for cells that are not NA.\n\n\n8.3.8 Summarizing functions\nWhen used with a SpatRaster object as first argument, normal summary statistics functions such as min, max and mean return a SpatRaster. You can use global if, instead, you want to obtain a summary for all cells of a single SpatRaster object. You can use freq to make a frequency table, or to count the number of cells with a specified value. Use zonal to summarize a SpatRaster object using zones (areas with the same integer number) defined in a SpatRaster and crosstab to cross-tabulate two SpatRaster objects.\n\nr &lt;- rast(ncol = 36, nrow = 18)\nvalues(r) &lt;- runif(ncell(r))\nglobal(r, mean)\n\n           mean\nlyr.1 0.4913016\n\n\nZonal stats, below r has the cells we want to summarize, s defines the zones, and the last argument is the function to summarize the values of r for each zone in s.\n\ns &lt;- r\nvalues(s) &lt;- round(runif(ncell(r)) * 5)\nzonal(r, s, \"mean\")\n\n  lyr.1   lyr.1.1\n1     0 0.5379050\n2     1 0.4834690\n3     2 0.4776720\n4     3 0.4837669\n5     4 0.4654671\n6     5 0.5415213\n\n\nCount cells\n\nfreq(s)\n\n  layer value count\n1     1     0    64\n2     1     1   138\n3     1     2   127\n4     1     3   121\n5     1     4   121\n6     1     5    77\n\nfreq(s, value = 3)\n\n  layer value count\n1     1     3   121\n\n\nCross-tabulate\n\nctb &lt;- crosstab(c(r * 3, s))\nhead(ctb)\n\n     lyr.1.1\nlyr.1  0  1  2  3  4  5\n    0  9 23 25 21 25  6\n    1 19 47 45 45 43 27\n    2 23 51 34 34 35 28\n    3 13 17 23 21 18 16\n\n\n\n\n8.3.9 Coercion to other classes\nYou can convert SpatRaster objects to Raster* objects defined in the raster package.\n\nr &lt;- rast(ncol = 36, nrow = 18)\nvalues(r) &lt;- runif(ncell(r))\nlibrary(raster)\n## Loading required package: sp\nx &lt;- raster(r)",
    "crumbs": [
      "Intro to Spatial Data"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html",
    "href": "R Basics/LGEO2185_IntroductionR.html",
    "title": "LGEO2185: Introduction To R",
    "section": "",
    "text": "R syntax (self-study)\nBasic R controls\nFun with R functions\nAssignment",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#todays-program",
    "href": "R Basics/LGEO2185_IntroductionR.html#todays-program",
    "title": "LGEO2185: Introduction To R",
    "section": "",
    "text": "R syntax (self-study)\nBasic R controls\nFun with R functions\nAssignment",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#todays-learning-objectives",
    "href": "R Basics/LGEO2185_IntroductionR.html#todays-learning-objectives",
    "title": "LGEO2185: Introduction To R",
    "section": "Today’s Learning Objectives",
    "text": "Today’s Learning Objectives\n\nKnowing what R is & what you can do with it\n\nGetting comfortable with functions\n\nLearn the basics of working with R\n\nThis first session is giving you basics of R, if you’re comfortable with the software, you can go directly to the assignments.\nWe will be using RStudio (IDE) or Positron as interface to R and geospatial libraries, since with R we can easily visualize and analyse data and maps!\n\n\n\n\n\n\nNote\n\n\n\nAnother option would it be Python, but here we use R here as it is easy to use across different platforms and there is a very active communities developing spatial libraries. However, all the skills from R are transferable to Python, the main difference is the syntax and available libraries. Note that libraries are called ‘Packages’ in R.\n\n\nThe first step is to explore the Rstudio environment - Source window - Console window - Environment window (including history) - Files, Plots, Packages, Viewer etc…\n\n\n\nSource: https://rstudio.github.io/cheatsheets/html/rstudio-ide.html\n\n\nPositron looks very similar but is based on a fork of Visual Studio Code, and adds support to Python as well. It features an integrated Console, Environment/Variables, Plots, Files, and Git tools familiar to RStudio users",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#self-study",
    "href": "R Basics/LGEO2185_IntroductionR.html#self-study",
    "title": "LGEO2185: Introduction To R",
    "section": "1.1 Self-Study",
    "text": "1.1 Self-Study\nSelf-study: follow the online course: Try R codeschool. This should allow you to understand the syntax used in R-scripts and how to manipulate different types of variables. There are a lot of references about computing with R !\n\n\n\n\n\n\nNote\n\n\n\nYou should develop a self-proficiency of R by yourself. We will look into using GenAI tools to augment your abilities later in the course, but a solid baseline is a pre-requisite: focus first on core syntax, data structures (vectors, matrices, data frames), and functions, practicing with small scripts and the provided references; once comfortable, we will introduce GenAI to responsibly accelerate your workflow.",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#setting-your-working-environment",
    "href": "R Basics/LGEO2185_IntroductionR.html#setting-your-working-environment",
    "title": "LGEO2185: Introduction To R",
    "section": "1.2 Setting your working environment",
    "text": "1.2 Setting your working environment\nLet’s first do some basic setup:\n- Create a folder which will be your working directory e.g. C:/Users/YourName/YourFolder\n- Create an R script within that folder\n- Create a data folder within your working directory\n\ngetwd() \nsetwd(\"C:/Users/YourName/YourFolder\") # This sets the working directory (where R looks for files)\ngetwd() # Double check your working directory \n\n\nwd=getwd()\ndatadir &lt;- paste0(wd,\"/data\")  # here we create a name for a subfolder called 'data'\ndir.create(datadir) # this creates the subdirectory\n\nYou will see that the variable datadir, i.e. the variable that you created above, is now visible in your workspace (Environment) and you can evaluate its value by clicking on it. Check out what Type the variables are. Create a vector and check again (you can see the type in the Environment, but also by calling the class() function)\nIf you are trying out code, it can be useful to clear all the variables that are stored in the workspace; this can be done by using:\nrm(list=ls()) # this removes all variables in the current workspace\nAlternatively, you can click Clear Workspace in the Session menu of the RStudio interface.",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#function-basics",
    "href": "R Basics/LGEO2185_IntroductionR.html#function-basics",
    "title": "LGEO2185: Introduction To R",
    "section": "1.3 Function basics",
    "text": "1.3 Function basics\nR functions take the form: functionName(arguments)\n\narguments are often optional (functions use default values)\nif arguments are not named, their position is used to assign values to arguments\nlaziness in argument naming is allowed, but dangerous\n\n\n# the following commands are equivalent\nrnorm(n=10)\n\n [1] -0.89254638 -0.64513885  0.09778594 -0.16365125  2.02789295 -1.96186930\n [7]  0.08998859  1.31141347  1.36680313 -0.88351480\n\nrnorm(n=10,mean=0,sd=1)\n\n [1] -0.04890219  0.28343846  1.76760767 -1.62872459  2.28860749 -1.55190044\n [7]  1.36828988 -0.50187046  0.06499514  0.87567529\n\nrnorm(10,0,1)\n\n [1]  1.4661618 -1.8990528 -0.9703153 -2.7903519  0.4298124  1.6731854\n [7]  1.2904619  0.1980907  1.6233606 -0.1141944\n\nrnorm(10,s=1,m=0)\n\n [1] -0.47771586 -0.64285622  0.83488555  0.03730523  1.24596555 -0.36451234\n [7]  0.26470005 -1.40744131  0.22754066 -1.90734058\n\n\nAccessing the help files can be done like this for a particular function;\n\n?mean\n\nIf you are looking for help files for a word or a phrase, use:\n\nhelp.search('weighted mean')",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#math",
    "href": "R Basics/LGEO2185_IntroductionR.html#math",
    "title": "LGEO2185: Introduction To R",
    "section": "1.4 Math",
    "text": "1.4 Math\nR could be used as a simple calculator, so you can easily find basics mathematics’s function that could be useful to integrate. Moreover, don’t forget your statistics knowledge that you have learned with your wonderful assistant with your best friend summary().",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#r-objects",
    "href": "R Basics/LGEO2185_IntroductionR.html#r-objects",
    "title": "LGEO2185: Introduction To R",
    "section": "1.5 R objects",
    "text": "1.5 R objects\nNew objects are created via the assignment operator : -&gt;\n\nx &lt;- 1\n# or 1 -&gt; x  : this can go one way or another\nx = 1 # This is an alternative, but not recommended\n\nAll R objects have two intrinsic attributes: mode (numeric, character, complex, logical) and length\n\ny &lt;- \"This is a character string\"\nz &lt;- TRUE # or alternatively: z &lt;- T\n!z\nmode(x);mode(y);mode(z) # the symbol ; can be used to put \n                         #several command in the same line\nlength(x)\n\n\nNon _intrinsic attributes of objects (eg row names, dimension, etc) can be accessed via the attributes function\nTesting the type of the object: is.numeric, is.character, etc…\nCoerce from one type to another: as.numeric, as.character, etc…\nMissing values and NULL object\n\n\nx &lt;- NA # NA means 'Not Available'\nx + 1 # Any operation on a NA gives a NA\n\n[1] NA\n\nx &lt;- NULL\nx + 1 # it returns a numeric object of length == 0\n\nnumeric(0)\n\n0/0 # NaN means 'Not a Number'\n\n[1] NaN\n\n1/0 # Infinity\n\n[1] Inf\n\n\nThere are several types of objects in R:\n\nsource: http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf\n\n1.5.1 Vectors\n\nCreating vectors\nThe easiest way to create a vector is to use the c (combine) function\n\nmy_vector &lt;- c(2, 4, 6)\nprint(my_vector)\n\n[1] 2 4 6\n\n\nThese are different ways to create vectors using a sequence:\n\n# an integer sequence\nv &lt;- 2:6\nv\n\n[1] 2 3 4 5 6\n\n# a complex sequence\nv &lt;- seq(2, 3, by=0.5)\nv\n\n[1] 2.0 2.5 3.0\n\n# a repeat vector\nv &lt;- rep(1:2, times = 3)\nv\n\n[1] 1 2 1 2 1 2\n\n# repeat elements of a vector\nv &lt;- rep(1:2, each=3)\nv\n\n[1] 1 1 1 2 2 2\n\n\n\narithmetic operators on numeric vectors are: +, -, *, /, ^, %% (modulus), %/% (integer division)\n\nlogical operators are: &lt;, &gt;, !=, ==, &lt;=, &gt;=, & (AND), | (OR), ! (negation)\nUsual functions applied to numeric vectors are: sqrt, sin, cos, tan, log, log10, exp, round, floor, ceiling, abs\n\nUsual summary functions are: min, max, sum, mean, median, sd, var, cumsum\n\nUsual functions to handle character strings are: paste, substr and grep, sub\n\n\nx &lt;- paste(\"var\",1:10,sep=\"_\");x # concatenate strings\n\n [1] \"var_1\"  \"var_2\"  \"var_3\"  \"var_4\"  \"var_5\"  \"var_6\"  \"var_7\"  \"var_8\" \n [9] \"var_9\"  \"var_10\"\n\nsubstr(x,start=1,stop=3) # extract and replace substrings in a character vector \n\n [1] \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\" \"var\"\n\nsub(pattern=\"[^1-9]+\",replacement=\"\",x) # sub uses regular expression \n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n\n                                        # to replace part of a charachter string\ngrep(pattern=\"10\",x) # grep returns the position of the matched pattern\n\n[1] 10\n\n\n\n\n\nSelecting vectors\nSometimes, it is really useful to make a selection of your data in order to reduce computing time and complexity. In a vector, you can use the [ ] to select specific columns and rows.\n\n\n\n1.5.2 factor\n\nA factor is a vector that stores categorical data\nA factor takes the following arguments: factor(x, levels = sort(unique(x), na.last = TRUE),labels = levels, exclude = NA, ordered = is.ordered(x))\n\n\nx &lt;- factor(paste(\"fac\",x[],sep=\"\"));x\n\n [1] facvar_1  facvar_2  facvar_3  facvar_4  facvar_5  facvar_6  facvar_7 \n [8] facvar_8  facvar_9  facvar_10\n10 Levels: facvar_1 facvar_10 facvar_2 facvar_3 facvar_4 facvar_5 ... facvar_9\n\ntable(x) # Frequency table\n\nx\n facvar_1 facvar_10  facvar_2  facvar_3  facvar_4  facvar_5  facvar_6  facvar_7 \n        1         1         1         1         1         1         1         1 \n facvar_8  facvar_9 \n        1         1 \n\n# factors can be ordered\nordered(c(\"two\",\"two\",\"one\",\"three\"),levels=c(\"one\",\"two\",\"three\"))\n\n[1] two   two   one   three\nLevels: one &lt; two &lt; three\n\n\n\n\n1.5.3 Matrixes\n\narray and matrix objects are multi–dimensional generalization of vectors\na matrix has the following arguments: matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,       dimnames = NULL)\n\n\nx &lt;- matrix(data=1:10,ncol=2,nrow=5);x # by default matrix cells are filled by column. \n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5   10\n\n                                       # Use byrow=T to change the behavior\ndim(x) # gives the dimension of an array\n\n[1] 5 2\n\ndimnames(x) &lt;- list(paste(\"X\",1:5,sep=\"\"),c(\"A\",\"B\"));x# dimnames (as well as colnames and rownames) defines\n\n   A  B\nX1 1  6\nX2 2  7\nX3 3  8\nX4 4  9\nX5 5 10\n\n                                                      #the name of the matrix dimension\nx &lt;- array(data=1:12,dim=c(2,3,2)) ;x\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\nx &lt;- array(data=1:5,dim=c(2,3,2));x # this works even though the number of data inputs is different\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    1\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    2    4    1\n[2,]    3    5    2\n\n                                    #than the number of cells! This is known as the *recycling* rule\n\n\narray and matrix are indexed with the [ function and , is used to select/separate dimensions\n\n\nx[1,,2] # first row, all the columns, second matrix of the array\n\n[1] 2 4 1\n\n\n\n\n\n1.5.4 list\n\nA list is a vector for which the elements or components can be of different mode\nThe list function have the form: list(name_1=object_1,name2=object_2,...,name_n=object_n)\nUse [[ or $ operators to index a list\n\n\nx &lt;-list(alphabet = LETTERS,numbers=1:length(LETTERS),\n         mat = matrix(ncol=10,nrow=10),ls = list(vec = 1:10));x # you can have a list inside a list ...\n\n$alphabet\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\n$mat\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [5,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n[10,]   NA   NA   NA   NA   NA   NA   NA   NA   NA    NA\n\n$ls\n$ls$vec\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx[[\"alphabet\"]]\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nx$alphabet # this is the same\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nx[[4]][[1]] # one can also extract components using their position in the list,\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n            # useful when the components of the list do not have a name\nx[1:2] # to extract several components, use only one [ \n\n$alphabet\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\nx &lt;- c(x,x) # list can be concatenated with the `c` function\n\n\n\n1.5.5 Dataframes (important!)\nDataframes are your best-friend and they are basically used as data tables providing you informations that could be number, character etc.\n\n\n\n\n\n\nAccess available Dataframes\nA lot of ready to use datasets are available in R. You can use this dataset to practice or to test your own functions. Have a look to the datasets available using data().\n\ndata(\"mtcars\")\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nstr(mtcars)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\nls() ## check the objective in the working environment\n\n[1] \"mtcars\"    \"my_vector\" \"R_HOME\"    \"v\"         \"x\"        \n\n\n\n\nSubsetting example\nLet’s have a practical example of subsetting. We will see here three main methods.\n\nmtcars[1,]\n\n          mpg cyl disp  hp drat   wt  qsec vs am gear carb\nMazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\nmtcars[,1]\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\n#1 classic\nmtcars[which(mtcars$wt&gt;3),]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n\n#2 with fuctions\nsubset(mtcars, wt &gt;3)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n\nsubset(mtcars, wt &gt;3, select = gear)\n\n                    gear\nHornet 4 Drive         3\nHornet Sportabout      3\nValiant                3\nDuster 360             3\nMerc 240D              4\nMerc 230               4\nMerc 280               4\nMerc 280C              4\nMerc 450SE             3\nMerc 450SL             3\nMerc 450SLC            3\nCadillac Fleetwood     3\nLincoln Continental    3\nChrysler Imperial      3\nDodge Challenger       3\nAMC Javelin            3\nCamaro Z28             3\nPontiac Firebird       3\nFord Pantera L         5\nMaserati Bora          5",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#write-and-read-data",
    "href": "R Basics/LGEO2185_IntroductionR.html#write-and-read-data",
    "title": "LGEO2185: Introduction To R",
    "section": "1.6 Write and read data",
    "text": "1.6 Write and read data\n\nwrite.csv(mtcars, \"my_mtcars.csv\")## write to your working directory \nlist.files()\n\n [1] \"_brand.yml\"            \"_quarto.yml\"           \"2025\"                 \n [4] \"biblio.bib\"            \"docs\"                  \"index.html\"           \n [7] \"index.qmd\"             \"Intro to Spatial Data\" \"logos\"                \n[10] \"my_mtcars.csv\"         \"PPT600_SC_16x9.potx\"   \"PPT600_SC_16x9.pptx\"  \n[13] \"R Basics\"              \"README.md\"             \"site_libs\"            \n[16] \"styles.css\"           \n\n\nThe most common way to read in spread sheet tables is with the read.csv() command. Type ?read.table in your R console to find out more about other formats.\n\nhp.data&lt;-read.csv(\"my_mtcars.csv\") ## read from your working directory\n\n# this is how to delete the data \nunlink(\"my_mtcars.csv\")\n\nR has a way of storing data in an object called a data frame. Consider this as an internal spreadsheet where all the relevant data items are stored. Run the line of code below, which loads a CSV file from my dropbox into a variable called hp.data\n\nclass(hp.data)\n\n[1] \"data.frame\"\n\n\nIt is always good to check if the data came in ok. You can do this by previewing the dataset with the head() function:\n\nhead(hp.data)\n\n                  X  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nNote that you can also click in the Environment window, which will show the data in a new tab, or use the command\n\nView(hp.data)\n\nUse the summary() function to explore basic statistics of your dataset.\nWe can use square brackets to look at specific sections of the data frame, for example hp.data[1,] or hp.data[,1]. We can also delete columns and create new columns using the code below. Remember to use the head() command as we did earlier to look at the data frame.\n\n#create a new column in hp.data dataframe call counciltax, storing the value NA\nhp.data$counciltax &lt;- NA\n#see what has happened\nhead(hp.data)\n\n                  X  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n  counciltax\n1         NA\n2         NA\n3         NA\n4         NA\n5         NA\n6         NA\n\n\n\n#delete a column\n hp.data$counciltax &lt;- NULL\n#see what has happened\nhead(hp.data)\n\n                  X  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\n#rename a column\ncolnames (hp.data)[1] &lt;- \"mpg2\"\n#see what has happened\nhead(hp.data)\n\n               mpg2  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nNow is a good time to remind you to save your data on a regular basis. This is particularly important if you are working on a project, and need to reload your data later on. R has a number of different elements you can save. The workspace is the most important element, as it contains any data frames or other objects you have created; i.e. everything listed in the Environment tab, like the hp.data object we created earlier. To do this, click the save button in the Environment tab. Choose somewhere to save it (your Documents folder is a good place) and give it a name. To load these in a new session, click File &gt; Open File and select your file.",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#computing-on-data",
    "href": "R Basics/LGEO2185_IntroductionR.html#computing-on-data",
    "title": "LGEO2185: Introduction To R",
    "section": "1.7 Computing on data",
    "text": "1.7 Computing on data\n\nIn R, a lot of computation can be realised in a vectorized form. No need for loops!\nAn operation on a vector of values works the same as it would do on a single value.\n\n\n# Compute the square of a vector in a traditional way\nX &lt;- 1:10\nsqX &lt;- numeric(length(X))\nfor(i in 1:length(sqX)){\n  sqX[i] &lt;- (X[i])^2  \n}\nsqX\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n# while it would have been much simpler (and faster) to write\nsqX &lt;- X^2\nmatrix(1:10,nrow=5,ncol=2)^2 # a given operation works often\n\n     [,1] [,2]\n[1,]    1   36\n[2,]    4   49\n[3,]    9   64\n[4,]   16   81\n[5,]   25  100\n\n                             #the same way for different data structure!\n\n\ncolSums, rowSums, colMeans, rowMeans allow to compute row and column sums and means of numeric arrays\n\n\ncolMeans(matrix(rnorm(100),ncol=10))\n\n [1]  0.06620507 -0.30203669 -0.41264765  0.25015003  0.02494486 -0.59367285\n [7]  0.24148816  0.08492192  0.42124271 -0.53708447\n\nrowSums(matrix(rnorm(100),ncol=10))\n\n [1] -1.78809649  2.08144298 -4.16539867 -0.82871392 -1.89990053 -1.36517676\n [7]  3.65729165  0.77171642 -6.52263824  0.03181284",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#if..else",
    "href": "R Basics/LGEO2185_IntroductionR.html#if..else",
    "title": "LGEO2185: Introduction To R",
    "section": "2.1 if..else",
    "text": "2.1 if..else\nThe basic syntax for creating an if..else statement in R is\n\nif(boolean_expression) {\n   // statement(s) will execute if the boolean expression is true.\n} else {\n   // statement(s) will execute if the boolean expression is false.\n}\n\n\n#let's generate some random numbers\nrand_data &lt;- rnorm(100, mean=0, sd=10)\n#it is now easy to plot a histogram of this vector:\nhist(rand_data)\n\n\n\n\n\n\n\n#Now, let us try to usean  if then statement\nif (mean(rand_data)&lt;0) {\n   print(\"The mean is below 0\")\n} else {\n   print(\"The mean is equal to or higher than 0\")\n}\n\n[1] \"The mean is below 0\"\n\n\nHave a look at the different operators that are available.",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#iteration-and-looping",
    "href": "R Basics/LGEO2185_IntroductionR.html#iteration-and-looping",
    "title": "LGEO2185: Introduction To R",
    "section": "2.2 Iteration and looping",
    "text": "2.2 Iteration and looping\nYou can also do something for all items in a vector or list.\n\na_vector &lt;- c(-10:10)\nfor (item in a_vector) {\n  print(item)\n}\n\n\n\n\n\n\n\nNote\n\n\n\n\nThere are other constructions possible (e.g. while, until, repeat …)\nHave a look also to the functions of the *apply family.\n\nSome examples below…\n\n# lapply function applies a function\n# to each element of X (being a vector or a list). \n# Remember that a data.frame is a special case of a list\nlapply(X=iris[,1:4],FUN=mean) \n\n$Sepal.Length\n[1] 5.843333\n\n$Sepal.Width\n[1] 3.057333\n\n$Petal.Length\n[1] 3.758\n\n$Petal.Width\n[1] 1.199333\n\n# sapply works the same way but returns the results nicely (if possible)\nsapply(X=iris[,1:4],FUN=mean) \n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.843333     3.057333     3.758000     1.199333 \n\n# Compute the median of the first 10 rows of the iris dataset\napply(X=iris[1:10,1:4],MARGIN=1,FUN=median) \n\n   1    2    3    4    5    6    7    8    9   10 \n2.45 2.20 2.25 2.30 2.50 2.80 2.40 2.45 2.15 2.30 \n\n# Compute the median of the first variable for each level of\n# the 5th variable. Note that X is a vector\ntapply(X=iris[,1],INDEX=iris[,5],FUN=median)  \n\n    setosa versicolor  virginica \n       5.0        5.9        6.5 \n\n# same as tapply but works on data.frames\nby(data=iris[,1:4],INDICES=iris[,5],FUN=mean) \n\niris[, 5]: setosa\n[1] NA\n------------------------------------------------------------ \niris[, 5]: versicolor\n[1] NA\n------------------------------------------------------------ \niris[, 5]: virginica\n[1] NA\n\n# idem\naggregate(x=iris[,1:4],by=list(Species=iris[,5]),FUN=mean)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#functions",
    "href": "R Basics/LGEO2185_IntroductionR.html#functions",
    "title": "LGEO2185: Introduction To R",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nOne of the great strengths of R is the user’s ability to add functions. In fact, many of the functions in R are actually functions of functions. The structure of a function is given below.\n\nmyfunction &lt;- function(arg1, arg2, ... ){\n  statements\n  return(object)\n}\n\nAn example:\n\nmy_multiply_function &lt;- function(base, multiplier){\nz &lt;- base*multiplier\nreturn(z)\n}\n#now lets use this simple function\nmy_multiply_function(5,5)\n\n[1] 25\n\n\nNice! Now it’s your turn:\n\nWrite your own function that calculates the sum of squares of two numbers\nCheck your function to evaluate the SS of 3 and 4, the answer is 25, right? Note that you give a name to the arguments when you define the function and you can use the arguments name in the commands section of the function.\nA function can return anything you want, a number, a list, a dataframe, nothing…\nWrite a function that calculates z=2*x+y, and returns a vector (z,x,y).\n\nYou can define a function in the same script as your code but you can also save your function as a separate R-file. Copy your sum of squares function into a new R-script (File -&gt; New File -&gt; R-script) and give it the same name as your function. You can now use the source() function to load your function from a file. The function is now available throughout your session!\n\nsource(\"sum_of_squares.R\")\n\nFrom the point of view of writing nice code, this approach is useful because it leaves you with an uncluttered analysis script, and a repository of useful functions that can be loaded into any analysis script in your project. It also lets you group related functions together easily.\n\n\n\n\n\n\nNote\n\n\n\nThe special argument ... (pronounced “dot-dot-dot”) is used to capture any number of additional arguments that are passed to a function. It is often used to forward arguments to another function. For example, you can create a wrapper function around a base function and allow users to pass additional parameters:\n\nmy_plot &lt;- function(x, y, ...) {\n  plot(x, y, ...)\n}\n\nHere, the ... will accept any extra parameters (e.g., col, pch, main) and forward them to the plot() function.",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR.html#assignment",
    "href": "R Basics/LGEO2185_IntroductionR.html#assignment",
    "title": "LGEO2185: Introduction To R",
    "section": "Assignment",
    "text": "Assignment\n\nRead this introduction about R functions\nCreate an R script, where you plot the mean, drawn from a normal distribution as function of the sample size. You should use the following elements: rnorm() function, matrix(), plot(), for {}. Make a function where the user can change the sample size considered, and the variables of the normal distribution. Bonus: do not use any for loops",
    "crumbs": [
      "R Basics",
      "Lecture"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LGEO2185",
    "section": "",
    "text": "This site contains course materials for LGEO2185. Github repository is available here",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "LGEO2185",
    "section": "",
    "text": "This site contains course materials for LGEO2185. Github repository is available here",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Create an R script, where you plot the mean, drawn from a normal distribution as function of the sample size. You should use the following elements: * rnorm() * matrix() * plot() * for {}\nMake a function where the user can change the sample size considered, and the variables of the normal distribution.\nBonus: do not use any for loops :-)\n\n\n\n\n\n\n\nImportantAnswer\n\n\n\n\n\n\n\n\n\nHard-coding of some parameters\nuse ... in function definition but not used within\nscript within for loop is not indented (not needed but lacks clarity)\nThe argument mean shadows the built-in mean() function (same for c). While this doesn’t immediately cause an error, it is bad practice because it can lead to confusion and bugs in more complex code where mean() might be expected.\nThe function doesn’t return any value. While it produces a plot, the underlying data (e.g., the matrix mat) isn’t accessible for further analysis. A good practice is to return the data structure used for plotting.\nInside the loop, the line c &lt;- c(2:1500) unnecessarily creates the same vector on every iteration.\n\n\nmyfun &lt;- function(mean, std, ...) {\n    # Generate 1500 random numbers from a normal distribution\n    random &lt;- rnorm(1500, mean = mean, sd = std)\n\n    # Create a matrix to store the sample size and sample means\n    mat &lt;- matrix(0, nrow = 1499, ncol = 2)\n\n    # Loop to calculate running means as sample size increases\n    for (i in 2:1500) {\n        moy &lt;- mean(random[1:i]) # Calculate the mean of the first 'i' samples\n        mat[i - 1, 2] &lt;- moy # Store the mean in the second column\n        c &lt;- c(2:1500) # Vector of sample sizes from 2 to 1500\n        mat[i - 1, 1] &lt;- c[i - 1] # Store the sample size in the first column\n    }\n\n    # Name the columns of the matrix\n    colnames(mat) &lt;- c(\"Size\", \"Mean\")\n\n    # Plot the sample size vs running mean\n    plot(mat, type = \"l\") # Line graph of sample size vs running mean\n    abline(mean, 0, col = \"red\") # Add a red horizontal line at the population mean\n}\n\n# Test the function\nmyfun(3, 4)\n\n\n\n\n\n\n\n\n\n\n\n\nWell documented\nUsing a relevant function name\n\n\n# Function to create mean vs. samplesize drawn from a normal distribution\nLawOfLargeNumbers &lt;- function(samplesize, mean, stdev) {\n    # samplesize: integer, number of samples\n    # mean: real, population mean\n    # stdev: real, population standard deviation\n    # Return: vector (size = samplesize) with running means\n\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mean, sd = stdev)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(0, samplesize),\n        ylim = c(-stdev, stdev),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(0, 0, col = \"red\") # Add a horizontal red line at y = 0\n\n    # Return the vector of running means\n    return(data_result)\n}\n\n# Generate running means for 100 samples, mean = 0, stdev = 1\nmeanvsss &lt;- LawOfLargeNumbers(100, 0, 1)\n\n\n\n\n\n\n\nhead(meanvsss)\n\n[1]  1.6982536369  0.5846183685  0.0700157647  0.2315591461 -0.0008028251\n[6] -0.3029825523\n\n\n\n\n\n\nPro tip: Use CTRL+SHIFT+R to your function, a way to organize documentation of function parameters and that can be used to create R documentation files (Rd)\n\n\n#' The Law of Large Numbers\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return A numeric vector of size \\code{samplesize}, containing the running means.\n#' @details The function generates a population distribution with the specified mean and\n#' standard deviation, calculates the running means for increasing sample sizes,\n#' and plots the running means against the sample size. A red horizontal line is drawn\n#' for the given \\code{mean}.\n#'\n#' @examples\n#' # Example usage:\n#' LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n\n    # Return the vector of running means\n    return(data_result)\n}\n\n\n\n\n\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nhead(LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1))\n\n[1]  0.91294545  0.37042086 -0.43834914  0.05366557  0.07591367  0.04577469\n\n\n\n\n\nThis OOP approach organizes the functionality into reusable methods and encapsulates the data and operations, making it easier to extend and maintain.\n\n#' The Law of Large Numbers (OOP with S3 Plot)\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return An object of class \\code{LawOfLargeNumbers}, containing the running means\n#' and the parameters used.\n#' @details The object has a custom \\code{plot()} method to visualize the running means against the sample size.\n#'\n#' @examples\n#' # Example usage:\n#' lln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#' plot(lln)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate population distribution and calculate running means\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n    running_sums &lt;- cumsum(pop_dist)\n    running_means &lt;- running_sums / seq_len(samplesize)\n\n    # Return the object with its associated class\n    structure(\n        list(\n            samplesize = samplesize,\n            mu = mu,\n            sigma = sigma,\n            running_means = running_means\n        ),\n        class = \"LawOfLargeNumbers\"\n    )\n}\n\n# Define a plot method for the LawOfLargeNumbers class\nplot.LawOfLargeNumbers &lt;- function(x, ...) {\n    # Extract information from the object\n    samplesize &lt;- x$samplesize\n    mu &lt;- x$mu\n    sigma &lt;- x$sigma\n    running_means &lt;- x$running_means\n\n    # Create the plot\n    plot(running_means,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(running_means) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n}\n\n# Create an object of class LawOfLargeNumbers\nlln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n\n# Plot the running means\nplot(lln)\n\n\n\n\n\n\n\n\n\n\n\n\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in rnorm(samplesize, mean = mu, sd = sigma): invalid arguments\n\n# Do some sanity checks\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Input validation\n    if (!is.numeric(samplesize) || samplesize &lt;= 0 || samplesize != as.integer(samplesize)) {\n        stop(\"samplesize must be a positive integer.\")\n    }\n    if (!is.numeric(mu)) stop(\"mu must be numeric.\")\n    if (!is.numeric(sigma) || sigma &lt;= 0) stop(\"sigma must be a positive numeric value.\")\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in LawOfLargeNumbers(-100, 0, 1): samplesize must be a positive integer.",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#hard-coding",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#hard-coding",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Hard-coding of some parameters\nuse ... in function definition but not used within\nscript within for loop is not indented (not needed but lacks clarity)\nThe argument mean shadows the built-in mean() function (same for c). While this doesn’t immediately cause an error, it is bad practice because it can lead to confusion and bugs in more complex code where mean() might be expected.\nThe function doesn’t return any value. While it produces a plot, the underlying data (e.g., the matrix mat) isn’t accessible for further analysis. A good practice is to return the data structure used for plotting.\nInside the loop, the line c &lt;- c(2:1500) unnecessarily creates the same vector on every iteration.\n\n\nmyfun &lt;- function(mean, std, ...) {\n    # Generate 1500 random numbers from a normal distribution\n    random &lt;- rnorm(1500, mean = mean, sd = std)\n\n    # Create a matrix to store the sample size and sample means\n    mat &lt;- matrix(0, nrow = 1499, ncol = 2)\n\n    # Loop to calculate running means as sample size increases\n    for (i in 2:1500) {\n        moy &lt;- mean(random[1:i]) # Calculate the mean of the first 'i' samples\n        mat[i - 1, 2] &lt;- moy # Store the mean in the second column\n        c &lt;- c(2:1500) # Vector of sample sizes from 2 to 1500\n        mat[i - 1, 1] &lt;- c[i - 1] # Store the sample size in the first column\n    }\n\n    # Name the columns of the matrix\n    colnames(mat) &lt;- c(\"Size\", \"Mean\")\n\n    # Plot the sample size vs running mean\n    plot(mat, type = \"l\") # Line graph of sample size vs running mean\n    abline(mean, 0, col = \"red\") # Add a red horizontal line at the population mean\n}\n\n# Test the function\nmyfun(3, 4)",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#solutions",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#solutions",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Well documented\nUsing a relevant function name\n\n\n# Function to create mean vs. samplesize drawn from a normal distribution\nLawOfLargeNumbers &lt;- function(samplesize, mean, stdev) {\n    # samplesize: integer, number of samples\n    # mean: real, population mean\n    # stdev: real, population standard deviation\n    # Return: vector (size = samplesize) with running means\n\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mean, sd = stdev)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(0, samplesize),\n        ylim = c(-stdev, stdev),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(0, 0, col = \"red\") # Add a horizontal red line at y = 0\n\n    # Return the vector of running means\n    return(data_result)\n}\n\n# Generate running means for 100 samples, mean = 0, stdev = 1\nmeanvsss &lt;- LawOfLargeNumbers(100, 0, 1)\n\n\n\n\n\n\n\nhead(meanvsss)\n\n[1]  1.6982536369  0.5846183685  0.0700157647  0.2315591461 -0.0008028251\n[6] -0.3029825523",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#improved-documentation",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#improved-documentation",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "Pro tip: Use CTRL+SHIFT+R to your function, a way to organize documentation of function parameters and that can be used to create R documentation files (Rd)\n\n\n#' The Law of Large Numbers\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return A numeric vector of size \\code{samplesize}, containing the running means.\n#' @details The function generates a population distribution with the specified mean and\n#' standard deviation, calculates the running means for increasing sample sizes,\n#' and plots the running means against the sample size. A red horizontal line is drawn\n#' for the given \\code{mean}.\n#'\n#' @examples\n#' # Example usage:\n#' LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Initialize a vector to store running means\n    data_result &lt;- c()\n\n    # Calculate running means for increasing sample sizes\n    for (i in 1:samplesize) {\n        data_result[i] &lt;- mean(pop_dist[1:i])\n    }\n\n    # Plot the running means\n    plot(data_result,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(data_result) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n\n    # Return the vector of running means\n    return(data_result)\n}",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#instead-of-loops-use-vectorization",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#instead-of-loops-use-vectorization",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "LawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nhead(LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1))\n\n[1]  0.91294545  0.37042086 -0.43834914  0.05366557  0.07591367  0.04577469",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#pro-use-object-oriented-design",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#pro-use-object-oriented-design",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "This OOP approach organizes the functionality into reusable methods and encapsulates the data and operations, making it easier to extend and maintain.\n\n#' The Law of Large Numbers (OOP with S3 Plot)\n#'\n#' The Law of Large Numbers states that as the sample size grows, the sample mean\n#' gets closer to the population mean.\n#'\n#' @param samplesize Integer. The number of samples to draw from the normal distribution.\n#' @param mu Numeric. The population mean of the normal distribution.\n#' @param sigma Numeric. The population standard deviation of the normal distribution.\n#'\n#' @return An object of class \\code{LawOfLargeNumbers}, containing the running means\n#' and the parameters used.\n#' @details The object has a custom \\code{plot()} method to visualize the running means against the sample size.\n#'\n#' @examples\n#' # Example usage:\n#' lln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n#' plot(lln)\n#'\n#' @export\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate population distribution and calculate running means\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n    running_sums &lt;- cumsum(pop_dist)\n    running_means &lt;- running_sums / seq_len(samplesize)\n\n    # Return the object with its associated class\n    structure(\n        list(\n            samplesize = samplesize,\n            mu = mu,\n            sigma = sigma,\n            running_means = running_means\n        ),\n        class = \"LawOfLargeNumbers\"\n    )\n}\n\n# Define a plot method for the LawOfLargeNumbers class\nplot.LawOfLargeNumbers &lt;- function(x, ...) {\n    # Extract information from the object\n    samplesize &lt;- x$samplesize\n    mu &lt;- x$mu\n    sigma &lt;- x$sigma\n    running_means &lt;- x$running_means\n\n    # Create the plot\n    plot(running_means,\n        pch = 3, cex = 0.3,\n        xlab = \"Sample Size\",\n        ylab = \"Sample Mean\",\n        xlim = c(1, samplesize),\n        ylim = c(mu - 3 * sigma, mu + 3 * sigma),\n        main = \"The Law of the Large Numbers\"\n    )\n    lines(running_means) # Connect the points with a line\n    abline(h = mu, col = \"red\") # Add a horizontal red line at the population mean\n}\n\n# Create an object of class LawOfLargeNumbers\nlln &lt;- LawOfLargeNumbers(samplesize = 1000, mu = 0, sigma = 1)\n\n# Plot the running means\nplot(lln)",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  },
  {
    "objectID": "R Basics/LGEO2185_IntroductionR_assignment.html#dont-forget-input-validation",
    "href": "R Basics/LGEO2185_IntroductionR_assignment.html#dont-forget-input-validation",
    "title": "LGEO2185: Introduction To R - Assignment",
    "section": "",
    "text": "LawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in rnorm(samplesize, mean = mu, sd = sigma): invalid arguments\n\n# Do some sanity checks\nLawOfLargeNumbers &lt;- function(samplesize, mu, sigma) {\n    # Input validation\n    if (!is.numeric(samplesize) || samplesize &lt;= 0 || samplesize != as.integer(samplesize)) {\n        stop(\"samplesize must be a positive integer.\")\n    }\n    if (!is.numeric(mu)) stop(\"mu must be numeric.\")\n    if (!is.numeric(sigma) || sigma &lt;= 0) stop(\"sigma must be a positive numeric value.\")\n    # Generate a population distribution with specified mean and standard deviation\n    pop_dist &lt;- rnorm(samplesize, mean = mu, sd = sigma)\n\n    # Calculate running means using cumulative sums\n    running_sums &lt;- cumsum(pop_dist)\n    data_result &lt;- running_sums / seq_len(samplesize)\n\n    # Alternative, using dplyr\n    # data_result &lt;- dplyr::cummean(pop_dist)\n\n    # Return the vector of running means\n    return(data_result)\n}\n\nLawOfLargeNumbers(-100, 0, 1)\n\nError in LawOfLargeNumbers(-100, 0, 1): samplesize must be a positive integer.",
    "crumbs": [
      "R Basics",
      "Assignment"
    ]
  }
]